// Generated by AshTypescript
// Do not edit this file manually

import { z } from "zod";




export type AshDate = string;
export type Decimal = string;
export type UUID = string;
export type UtcDateTime = string;
export type UtcDateTimeUsec = string;

// User Schema
export type UserResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "firstName" | "lastName" | "phone" | "role" | "specialization" | "accountManagerId" | "isActive" | "canUseAiChat" | "companyId" | "isSiteflowStaff" | "isDeveloper" | "canInviteUsers" | "hasAiAccess";
  id: UUID;
  email: string;
  firstName: string;
  lastName: string;
  phone: string | null;
  role: "siteflow_admin" | "siteflow_kam" | "siteflow_pl" | "siteflow_dev_frontend" | "siteflow_dev_backend" | "siteflow_dev_fullstack" | "customer" | "partner" | null;
  specialization: string | null;
  accountManagerId: UUID | null;
  isActive: boolean | null;
  canUseAiChat: boolean;
  companyId: UUID | null;
  isSiteflowStaff: boolean | null;
  isDeveloper: boolean | null;
  canInviteUsers: boolean | null;
  hasAiAccess: boolean | null;
  company: { __type: "Relationship"; __resource: CompanyResourceSchema | null; };
  accountManager: { __type: "Relationship"; __resource: UserResourceSchema | null; };
  managedCustomers: { __type: "Relationship"; __array: true; __resource: UserResourceSchema; };
};



// Company Schema
export type CompanyResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "orgNumber" | "address" | "city" | "postalCode" | "country" | "phone" | "website" | "isActive" | "employeeCount" | "industry" | "logoUrl" | "billingAddress" | "billingCity" | "billingPostalCode" | "billingCountry";
  id: UUID;
  name: string;
  orgNumber: string | null;
  address: string | null;
  city: string | null;
  postalCode: string | null;
  country: string | null;
  phone: string | null;
  website: string | null;
  isActive: boolean | null;
  employeeCount: string | null;
  industry: string | null;
  logoUrl: string | null;
  billingAddress: string | null;
  billingCity: string | null;
  billingPostalCode: string | null;
  billingCountry: string | null;
};



// Project Schema
export type ProjectResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description" | "state" | "budget" | "spent" | "startDate" | "targetEndDate" | "actualEndDate" | "approvedAt" | "rejectionReason" | "cancellationReason" | "isPriority" | "companyId";
  id: UUID;
  name: string;
  description: string | null;
  state: "draft" | "pending_approval" | "in_progress" | "on_hold" | "completed" | "cancelled";
  budget: Decimal | null;
  spent: Decimal | null;
  startDate: AshDate | null;
  targetEndDate: AshDate | null;
  actualEndDate: UtcDateTime | null;
  approvedAt: UtcDateTime | null;
  rejectionReason: string | null;
  cancellationReason: string | null;
  isPriority: boolean;
  companyId: UUID;
  company: { __type: "Relationship"; __resource: CompanyResourceSchema; };
};



// Ticket Schema
export type TicketResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "state" | "priority" | "category" | "reviewNotes" | "resolvedAt" | "projectId" | "reporterId" | "assigneeId";
  id: UUID;
  title: string;
  description: string | null;
  state: "open" | "in_progress" | "in_review" | "resolved" | "closed";
  priority: "low" | "medium" | "high" | "critical" | null;
  category: "bug" | "feature" | "support" | "question" | "task" | null;
  reviewNotes: string | null;
  resolvedAt: UtcDateTime | null;
  projectId: UUID;
  reporterId: UUID | null;
  assigneeId: UUID | null;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  reporter: { __type: "Relationship"; __resource: UserResourceSchema | null; };
  assignee: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};



// Comment Schema
export type CommentResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "body" | "isInternal" | "ticketId" | "authorId";
  id: UUID;
  body: string;
  isInternal: boolean | null;
  ticketId: UUID;
  authorId: UUID;
  ticket: { __type: "Relationship"; __resource: TicketResourceSchema; };
  author: { __type: "Relationship"; __resource: UserResourceSchema; };
};



// TimeEntry Schema
export type TimeEntryResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "description" | "hours" | "date" | "hourlyRate" | "isBillable" | "projectId" | "ticketId" | "userId";
  id: UUID;
  description: string | null;
  hours: Decimal;
  date: AshDate;
  hourlyRate: Decimal | null;
  isBillable: boolean | null;
  projectId: UUID;
  ticketId: UUID | null;
  userId: UUID;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  ticket: { __type: "Relationship"; __resource: TicketResourceSchema | null; };
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



// Document Schema
export type DocumentResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "name" | "description" | "filePath" | "fileSize" | "mimeType" | "category" | "projectId" | "uploadedById";
  id: UUID;
  name: string;
  description: string | null;
  filePath: string;
  fileSize: number | null;
  mimeType: string | null;
  category: "contract" | "specification" | "design" | "report" | "invoice" | "other" | null;
  projectId: UUID;
  uploadedById: UUID;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  uploadedBy: { __type: "Relationship"; __resource: UserResourceSchema; };
};



// Invitation Schema
export type InvitationResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "email" | "role" | "expiresAt" | "acceptedAt" | "cancelledAt" | "companyId" | "invitedById" | "acceptedById";
  id: UUID;
  email: string;
  role: "customer" | null;
  expiresAt: UtcDateTime;
  acceptedAt: UtcDateTime | null;
  cancelledAt: UtcDateTime | null;
  companyId: UUID;
  invitedById: UUID;
  acceptedById: UUID | null;
  company: { __type: "Relationship"; __resource: CompanyResourceSchema; };
  invitedBy: { __type: "Relationship"; __resource: UserResourceSchema; };
  acceptedBy: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};



// FormResponse Schema
export type FormResponseResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "formType" | "section" | "questionKey" | "answerValue" | "answerMetadata";
  id: UUID;
  formType: "website" | "system" | "both";
  section: string;
  questionKey: string;
  answerValue: Record<string, any>;
  answerMetadata: Record<string, any> | null;
};



// InternalNote Schema
export type InternalNoteResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "content" | "projectId" | "authorId";
  id: UUID;
  content: string;
  projectId: UUID;
  authorId: UUID;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  author: { __type: "Relationship"; __resource: UserResourceSchema; };
};



// GeneratedDocument Schema
export type GeneratedDocumentResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "documentType" | "title" | "content" | "version" | "status" | "generationMetadata" | "projectId" | "generatedById";
  id: UUID;
  documentType: "project_spec" | "technical_requirements" | "design_brief" | "budget_timeline";
  title: string;
  content: string;
  version: number;
  status: "draft" | "published" | "archived";
  generationMetadata: Record<string, any> | null;
  projectId: UUID;
  generatedById: UUID | null;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  generatedBy: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};



// ChatMessage Schema
export type ChatMessageResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "role" | "content" | "sources" | "metadata" | "projectId" | "userId";
  id: UUID;
  role: "user" | "assistant";
  content: string;
  sources: Array<Record<string, any>> | null;
  metadata: Record<string, any> | null;
  projectId: UUID;
  userId: UUID;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  user: { __type: "Relationship"; __resource: UserResourceSchema; };
};



// ManualKnowledgeEntry Schema
export type ManualKnowledgeEntryResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "content" | "rawInput" | "category" | "metadata" | "projectId" | "createdById";
  id: UUID;
  title: string;
  content: string;
  rawInput: string | null;
  category: "meeting_notes" | "decision" | "clarification" | "feedback" | "technical" | "design" | "other";
  metadata: Record<string, any> | null;
  projectId: UUID;
  createdById: UUID;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  createdBy: { __type: "Relationship"; __resource: UserResourceSchema; };
};



// ProductPlan Schema
export type ProductPlanResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "content" | "summary" | "pdfUrl" | "version" | "status" | "sentAt" | "viewedAt" | "approvedAt" | "rejectedAt" | "customerFeedback" | "changeRequests" | "metadata" | "projectId" | "createdById" | "approvedById" | "isPendingCustomerAction" | "isApproved" | "needsAdminAction" | "daysSinceSent";
  id: UUID;
  title: string;
  content: string;
  summary: string | null;
  pdfUrl: string | null;
  version: number;
  status: "draft" | "sent" | "viewed" | "approved" | "changes_requested" | "revised" | "archived";
  sentAt: UtcDateTimeUsec | null;
  viewedAt: UtcDateTimeUsec | null;
  approvedAt: UtcDateTimeUsec | null;
  rejectedAt: UtcDateTimeUsec | null;
  customerFeedback: string | null;
  changeRequests: Record<string, any> | null;
  metadata: Record<string, any> | null;
  projectId: UUID;
  createdById: UUID | null;
  approvedById: UUID | null;
  isPendingCustomerAction: boolean | null;
  isApproved: boolean | null;
  needsAdminAction: boolean | null;
  daysSinceSent: number | null;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  createdBy: { __type: "Relationship"; __resource: UserResourceSchema | null; };
  approvedBy: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};



// Milestone Schema
export type MilestoneResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "dueDate" | "completedAt" | "orderIndex" | "status" | "projectId" | "createdById";
  id: UUID;
  title: string;
  description: string | null;
  dueDate: AshDate | null;
  completedAt: UtcDateTimeUsec | null;
  orderIndex: number | null;
  status: "pending" | "in_progress" | "completed" | null;
  projectId: UUID;
  createdById: UUID | null;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  createdBy: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};



// Meeting Schema
export type MeetingResourceSchema = {
  __type: "Resource";
  __primitiveFields: "id" | "title" | "description" | "meetingType" | "scheduledAt" | "durationMinutes" | "location" | "meetingUrl" | "notes" | "actionItems" | "attendees" | "status" | "projectId" | "createdById";
  id: UUID;
  title: string;
  description: string | null;
  meetingType: "kickoff" | "status_update" | "review" | "planning" | "retrospective" | "other" | null;
  scheduledAt: UtcDateTimeUsec | null;
  durationMinutes: number | null;
  location: string | null;
  meetingUrl: string | null;
  notes: string | null;
  actionItems: Record<string, any> | null;
  attendees: Array<string> | null;
  status: "scheduled" | "in_progress" | "completed" | "cancelled" | null;
  projectId: UUID;
  createdById: UUID | null;
  project: { __type: "Relationship"; __resource: ProjectResourceSchema; };
  createdBy: { __type: "Relationship"; __resource: UserResourceSchema | null; };
};





export type UserFilterInput = {
  and?: Array<UserFilterInput>;
  or?: Array<UserFilterInput>;
  not?: Array<UserFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  firstName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  lastName?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  phone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  role?: {
    eq?: "siteflow_admin" | "siteflow_kam" | "siteflow_pl" | "siteflow_dev_frontend" | "siteflow_dev_backend" | "siteflow_dev_fullstack" | "customer" | "partner";
    notEq?: "siteflow_admin" | "siteflow_kam" | "siteflow_pl" | "siteflow_dev_frontend" | "siteflow_dev_backend" | "siteflow_dev_fullstack" | "customer" | "partner";
    in?: Array<"siteflow_admin" | "siteflow_kam" | "siteflow_pl" | "siteflow_dev_frontend" | "siteflow_dev_backend" | "siteflow_dev_fullstack" | "customer" | "partner">;
  };

  specialization?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  accountManagerId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  isActive?: {
    eq?: boolean;
    notEq?: boolean;
  };

  canUseAiChat?: {
    eq?: boolean;
    notEq?: boolean;
  };

  companyId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  isSiteflowStaff?: {
    eq?: boolean;
    notEq?: boolean;
  };

  isDeveloper?: {
    eq?: boolean;
    notEq?: boolean;
  };

  canInviteUsers?: {
    eq?: boolean;
    notEq?: boolean;
  };

  hasAiAccess?: {
    eq?: boolean;
    notEq?: boolean;
  };


  company?: CompanyFilterInput;

  accountManager?: UserFilterInput;

  managedCustomers?: UserFilterInput;

};
export type CompanyFilterInput = {
  and?: Array<CompanyFilterInput>;
  or?: Array<CompanyFilterInput>;
  not?: Array<CompanyFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  orgNumber?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  address?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  city?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  postalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  country?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  phone?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  website?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isActive?: {
    eq?: boolean;
    notEq?: boolean;
  };

  employeeCount?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  industry?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  logoUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  billingAddress?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  billingCity?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  billingPostalCode?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  billingCountry?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };



};
export type ProjectFilterInput = {
  and?: Array<ProjectFilterInput>;
  or?: Array<ProjectFilterInput>;
  not?: Array<ProjectFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  state?: {
    eq?: "draft" | "pending_approval" | "in_progress" | "on_hold" | "completed" | "cancelled";
    notEq?: "draft" | "pending_approval" | "in_progress" | "on_hold" | "completed" | "cancelled";
    in?: Array<"draft" | "pending_approval" | "in_progress" | "on_hold" | "completed" | "cancelled">;
  };

  budget?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  spent?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  startDate?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  targetEndDate?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  actualEndDate?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  approvedAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  rejectionReason?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  cancellationReason?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isPriority?: {
    eq?: boolean;
    notEq?: boolean;
  };

  companyId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  company?: CompanyFilterInput;

};
export type TicketFilterInput = {
  and?: Array<TicketFilterInput>;
  or?: Array<TicketFilterInput>;
  not?: Array<TicketFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  state?: {
    eq?: "open" | "in_progress" | "in_review" | "resolved" | "closed";
    notEq?: "open" | "in_progress" | "in_review" | "resolved" | "closed";
    in?: Array<"open" | "in_progress" | "in_review" | "resolved" | "closed">;
  };

  priority?: {
    eq?: "low" | "medium" | "high" | "critical";
    notEq?: "low" | "medium" | "high" | "critical";
    in?: Array<"low" | "medium" | "high" | "critical">;
  };

  category?: {
    eq?: "bug" | "feature" | "support" | "question" | "task";
    notEq?: "bug" | "feature" | "support" | "question" | "task";
    in?: Array<"bug" | "feature" | "support" | "question" | "task">;
  };

  reviewNotes?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  resolvedAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  reporterId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  assigneeId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  reporter?: UserFilterInput;

  assignee?: UserFilterInput;

};
export type CommentFilterInput = {
  and?: Array<CommentFilterInput>;
  or?: Array<CommentFilterInput>;
  not?: Array<CommentFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  body?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  isInternal?: {
    eq?: boolean;
    notEq?: boolean;
  };

  ticketId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  authorId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  ticket?: TicketFilterInput;

  author?: UserFilterInput;

};
export type TimeEntryFilterInput = {
  and?: Array<TimeEntryFilterInput>;
  or?: Array<TimeEntryFilterInput>;
  not?: Array<TimeEntryFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  hours?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  date?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  hourlyRate?: {
    eq?: Decimal;
    notEq?: Decimal;
    greaterThan?: Decimal;
    greaterThanOrEqual?: Decimal;
    lessThan?: Decimal;
    lessThanOrEqual?: Decimal;
    in?: Array<Decimal>;
  };

  isBillable?: {
    eq?: boolean;
    notEq?: boolean;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  ticketId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  ticket?: TicketFilterInput;

  user?: UserFilterInput;

};
export type DocumentFilterInput = {
  and?: Array<DocumentFilterInput>;
  or?: Array<DocumentFilterInput>;
  not?: Array<DocumentFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  name?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  filePath?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  fileSize?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  mimeType?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  category?: {
    eq?: "contract" | "specification" | "design" | "report" | "invoice" | "other";
    notEq?: "contract" | "specification" | "design" | "report" | "invoice" | "other";
    in?: Array<"contract" | "specification" | "design" | "report" | "invoice" | "other">;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  uploadedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  uploadedBy?: UserFilterInput;

};
export type InvitationFilterInput = {
  and?: Array<InvitationFilterInput>;
  or?: Array<InvitationFilterInput>;
  not?: Array<InvitationFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  email?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  role?: {
    eq?: "customer";
    notEq?: "customer";
    in?: Array<"customer">;
  };

  expiresAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  acceptedAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  cancelledAt?: {
    eq?: UtcDateTime;
    notEq?: UtcDateTime;
    greaterThan?: UtcDateTime;
    greaterThanOrEqual?: UtcDateTime;
    lessThan?: UtcDateTime;
    lessThanOrEqual?: UtcDateTime;
    in?: Array<UtcDateTime>;
  };

  companyId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  invitedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  acceptedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  company?: CompanyFilterInput;

  invitedBy?: UserFilterInput;

  acceptedBy?: UserFilterInput;

};
export type FormResponseFilterInput = {
  and?: Array<FormResponseFilterInput>;
  or?: Array<FormResponseFilterInput>;
  not?: Array<FormResponseFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  formType?: {
    eq?: "website" | "system" | "both";
    notEq?: "website" | "system" | "both";
    in?: Array<"website" | "system" | "both">;
  };

  section?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  questionKey?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  answerValue?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  answerMetadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };



};
export type InternalNoteFilterInput = {
  and?: Array<InternalNoteFilterInput>;
  or?: Array<InternalNoteFilterInput>;
  not?: Array<InternalNoteFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  authorId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  author?: UserFilterInput;

};
export type GeneratedDocumentFilterInput = {
  and?: Array<GeneratedDocumentFilterInput>;
  or?: Array<GeneratedDocumentFilterInput>;
  not?: Array<GeneratedDocumentFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  documentType?: {
    eq?: "project_spec" | "technical_requirements" | "design_brief" | "budget_timeline";
    notEq?: "project_spec" | "technical_requirements" | "design_brief" | "budget_timeline";
    in?: Array<"project_spec" | "technical_requirements" | "design_brief" | "budget_timeline">;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  version?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  status?: {
    eq?: "draft" | "published" | "archived";
    notEq?: "draft" | "published" | "archived";
    in?: Array<"draft" | "published" | "archived">;
  };

  generationMetadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  generatedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  generatedBy?: UserFilterInput;

};
export type ChatMessageFilterInput = {
  and?: Array<ChatMessageFilterInput>;
  or?: Array<ChatMessageFilterInput>;
  not?: Array<ChatMessageFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  role?: {
    eq?: "user" | "assistant";
    notEq?: "user" | "assistant";
    in?: Array<"user" | "assistant">;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  sources?: {
    eq?: Array<Record<string, any>>;
    notEq?: Array<Record<string, any>>;
    in?: Array<Array<Record<string, any>>>;
  };

  metadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  userId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  user?: UserFilterInput;

};
export type ManualKnowledgeEntryFilterInput = {
  and?: Array<ManualKnowledgeEntryFilterInput>;
  or?: Array<ManualKnowledgeEntryFilterInput>;
  not?: Array<ManualKnowledgeEntryFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  rawInput?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  category?: {
    eq?: "meeting_notes" | "decision" | "clarification" | "feedback" | "technical" | "design" | "other";
    notEq?: "meeting_notes" | "decision" | "clarification" | "feedback" | "technical" | "design" | "other";
    in?: Array<"meeting_notes" | "decision" | "clarification" | "feedback" | "technical" | "design" | "other">;
  };

  metadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  createdBy?: UserFilterInput;

};
export type ProductPlanFilterInput = {
  and?: Array<ProductPlanFilterInput>;
  or?: Array<ProductPlanFilterInput>;
  not?: Array<ProductPlanFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  content?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  summary?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  pdfUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  version?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  status?: {
    eq?: "draft" | "sent" | "viewed" | "approved" | "changes_requested" | "revised" | "archived";
    notEq?: "draft" | "sent" | "viewed" | "approved" | "changes_requested" | "revised" | "archived";
    in?: Array<"draft" | "sent" | "viewed" | "approved" | "changes_requested" | "revised" | "archived">;
  };

  sentAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  viewedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  approvedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  rejectedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  customerFeedback?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  changeRequests?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  metadata?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  approvedById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  isPendingCustomerAction?: {
    eq?: boolean;
    notEq?: boolean;
  };

  isApproved?: {
    eq?: boolean;
    notEq?: boolean;
  };

  needsAdminAction?: {
    eq?: boolean;
    notEq?: boolean;
  };

  daysSinceSent?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };


  project?: ProjectFilterInput;

  createdBy?: UserFilterInput;

  approvedBy?: UserFilterInput;

};
export type MilestoneFilterInput = {
  and?: Array<MilestoneFilterInput>;
  or?: Array<MilestoneFilterInput>;
  not?: Array<MilestoneFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  dueDate?: {
    eq?: AshDate;
    notEq?: AshDate;
    greaterThan?: AshDate;
    greaterThanOrEqual?: AshDate;
    lessThan?: AshDate;
    lessThanOrEqual?: AshDate;
    in?: Array<AshDate>;
  };

  completedAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  orderIndex?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  status?: {
    eq?: "pending" | "in_progress" | "completed";
    notEq?: "pending" | "in_progress" | "completed";
    in?: Array<"pending" | "in_progress" | "completed">;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  createdBy?: UserFilterInput;

};
export type MeetingFilterInput = {
  and?: Array<MeetingFilterInput>;
  or?: Array<MeetingFilterInput>;
  not?: Array<MeetingFilterInput>;

  id?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  title?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  description?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  meetingType?: {
    eq?: "kickoff" | "status_update" | "review" | "planning" | "retrospective" | "other";
    notEq?: "kickoff" | "status_update" | "review" | "planning" | "retrospective" | "other";
    in?: Array<"kickoff" | "status_update" | "review" | "planning" | "retrospective" | "other">;
  };

  scheduledAt?: {
    eq?: UtcDateTimeUsec;
    notEq?: UtcDateTimeUsec;
    greaterThan?: UtcDateTimeUsec;
    greaterThanOrEqual?: UtcDateTimeUsec;
    lessThan?: UtcDateTimeUsec;
    lessThanOrEqual?: UtcDateTimeUsec;
    in?: Array<UtcDateTimeUsec>;
  };

  durationMinutes?: {
    eq?: number;
    notEq?: number;
    greaterThan?: number;
    greaterThanOrEqual?: number;
    lessThan?: number;
    lessThanOrEqual?: number;
    in?: Array<number>;
  };

  location?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  meetingUrl?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  notes?: {
    eq?: string;
    notEq?: string;
    in?: Array<string>;
  };

  actionItems?: {
    eq?: Record<string, any>;
    notEq?: Record<string, any>;
    in?: Array<Record<string, any>>;
  };

  attendees?: {
    eq?: Array<string>;
    notEq?: Array<string>;
    in?: Array<Array<string>>;
  };

  status?: {
    eq?: "scheduled" | "in_progress" | "completed" | "cancelled";
    notEq?: "scheduled" | "in_progress" | "completed" | "cancelled";
    in?: Array<"scheduled" | "in_progress" | "completed" | "cancelled">;
  };

  projectId?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };

  createdById?: {
    eq?: UUID;
    notEq?: UUID;
    in?: Array<UUID>;
  };


  project?: ProjectFilterInput;

  createdBy?: UserFilterInput;

};


// Utility Types

// Resource schema constraint
type TypedSchema = {
  __type: "Resource" | "TypedMap" | "Union";
  __primitiveFields: string;
};

// Utility type to convert union to intersection
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;

// Helper type to infer union field values, avoiding duplication between array and non-array unions
type InferUnionFieldValue<
  UnionSchema extends { __type: "Union"; __primitiveFields: any },
  FieldSelection extends any[],
> = UnionToIntersection<
  {
    [FieldIndex in keyof FieldSelection]: FieldSelection[FieldIndex] extends UnionSchema["__primitiveFields"]
      ? FieldSelection[FieldIndex] extends keyof UnionSchema
        ? { [P in FieldSelection[FieldIndex]]: UnionSchema[FieldSelection[FieldIndex]] }
        : never
      : FieldSelection[FieldIndex] extends Record<string, any>
        ? {
            [UnionKey in keyof FieldSelection[FieldIndex]]: UnionKey extends keyof UnionSchema
              ? UnionSchema[UnionKey] extends { __array: true; __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                ? FieldSelection[FieldIndex][UnionKey] extends any[]
                  ? Array<
                      UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof UnionSchema[UnionKey]
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: UnionSchema[UnionKey][P] }
                              : never
                            : never;
                        }[number]
                      >
                    > | null
                  : never
                : UnionSchema[UnionKey] extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
                  ? FieldSelection[FieldIndex][UnionKey] extends any[]
                    ? UnionToIntersection<
                        {
                          [FieldIdx in keyof FieldSelection[FieldIndex][UnionKey]]: FieldSelection[FieldIndex][UnionKey][FieldIdx] extends TypedMapFields
                            ? FieldSelection[FieldIndex][UnionKey][FieldIdx] extends keyof UnionSchema[UnionKey]
                              ? { [P in FieldSelection[FieldIndex][UnionKey][FieldIdx]]: UnionSchema[UnionKey][P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : never
                  : UnionSchema[UnionKey] extends TypedSchema
                    ? InferResult<UnionSchema[UnionKey], FieldSelection[FieldIndex][UnionKey]>
                    : never
              : never;
          }
        : never;
  }[number]
>;

type HasComplexFields<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
> extends never
  ? false
  : true;

type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
  T,
  "__primitiveFields" | "__type" | T["__primitiveFields"]
>;

type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

type ComplexFieldSelection<T extends TypedSchema> = {
  [K in ComplexFieldKeys<T>]?: T[K] extends {
    __type: "Relationship";
    __resource: infer Resource;
  }
    ? NonNullable<Resource> extends TypedSchema
      ? UnifiedFieldSelection<NonNullable<Resource>>[]
      : never
    : T[K] extends {
          __type: "ComplexCalculation";
          __returnType: infer ReturnType;
        }
      ? T[K] extends { __args: infer Args }
        ? NonNullable<ReturnType> extends TypedSchema
          ? {
              args: Args;
              fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
            }
          : { args: Args }
        : NonNullable<ReturnType> extends TypedSchema
          ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
          : never
      : T[K] extends { __type: "TypedMap"; __primitiveFields: infer PrimitiveFields }
        ? PrimitiveFields[]
        : T[K] extends { __type: "Union"; __primitiveFields: infer PrimitiveFields }
          ? T[K] extends { __array: true }
            ? (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields" | "__array">]?: T[K][UnionKey] extends { __type: "TypedMap"; __primitiveFields: any }
                  ? T[K][UnionKey]["__primitiveFields"][]
                  : T[K][UnionKey] extends TypedSchema
                    ? UnifiedFieldSelection<T[K][UnionKey]>[]
                    : never;
              })[]
            : (PrimitiveFields | {
                [UnionKey in keyof Omit<T[K], "__type" | "__primitiveFields">]?: T[K][UnionKey] extends TypedSchema
                  ? T[K][UnionKey]["__primitiveFields"][]
                  : T[K][UnionKey] extends TypedSchema
                    ? UnifiedFieldSelection<T[K][UnionKey]>[]
                    : never;
              })[]
            : NonNullable<T[K]> extends TypedSchema
              ? UnifiedFieldSelection<NonNullable<T[K]>>[]
              : never;
};

// Main type: Use explicit base case detection to prevent infinite recursion
type UnifiedFieldSelection<T extends TypedSchema> =
  HasComplexFields<T> extends false
    ? LeafFieldSelection<T> // Base case: only primitives, no recursion
    : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

type InferFieldValue<
  T extends TypedSchema,
  Field,
> = Field extends T["__primitiveFields"]
  ? Field extends keyof T
    ? { [K in Field]: T[Field] }
    : never
  : Field extends Record<string, any>
    ? {
        [K in keyof Field]: K extends keyof T
          ? T[K] extends {
              __type: "Relationship";
              __resource: infer Resource;
            }
            ? NonNullable<Resource> extends TypedSchema
              ? T[K] extends { __array: true }
                ? Array<InferResult<NonNullable<Resource>, Field[K]>>
                : null extends Resource
                  ? InferResult<NonNullable<Resource>, Field[K]> | null
                  : InferResult<NonNullable<Resource>, Field[K]>
            : never
          : T[K] extends {
                __type: "ComplexCalculation";
                __returnType: infer ReturnType;
              }
            ? NonNullable<ReturnType> extends TypedSchema
              ? null extends ReturnType
                ? InferResult<NonNullable<ReturnType>, Field[K]["fields"]> | null
                : InferResult<NonNullable<ReturnType>, Field[K]["fields"]>
              : ReturnType
            : NonNullable<T[K]> extends { __type: "TypedMap"; __primitiveFields: infer TypedMapFields }
              ? NonNullable<T[K]> extends { __array: true }
                ? Field[K] extends any[]
                  ? null extends T[K]
                    ? Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                              ? Field[K][FieldIndex] extends keyof NonNullable<T[K]>
                                ? { [P in Field[K][FieldIndex]]: NonNullable<T[K]>[P] }
                                : never
                              : never;
                          }[number]
                        >
                      > | null
                    : Array<
                        UnionToIntersection<
                          {
                            [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                              ? Field[K][FieldIndex] extends keyof NonNullable<T[K]>
                                ? { [P in Field[K][FieldIndex]]: NonNullable<T[K]>[P] }
                                : never
                              : never;
                          }[number]
                        >
                      >
                  : never
                : Field[K] extends any[]
                  ? null extends T[K]
                    ? UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                            ? Field[K][FieldIndex] extends keyof NonNullable<T[K]>
                              ? { [P in Field[K][FieldIndex]]: NonNullable<T[K]>[P] }
                              : never
                            : never;
                        }[number]
                      > | null
                    : UnionToIntersection<
                        {
                          [FieldIndex in keyof Field[K]]: Field[K][FieldIndex] extends TypedMapFields
                            ? Field[K][FieldIndex] extends keyof T[K]
                              ? { [P in Field[K][FieldIndex]]: T[K][P] }
                              : never
                            : never;
                        }[number]
                      >
                  : never
              : T[K] extends { __type: "Union"; __primitiveFields: any }
                ? T[K] extends { __array: true }
                  ? {
                      [CurrentK in K]: T[CurrentK] extends { __type: "Union"; __primitiveFields: any }
                        ? Field[CurrentK] extends any[]
                          ? Array<InferUnionFieldValue<T[CurrentK], Field[CurrentK]>> | null
                          : never
                        : never
                    }
                  : {
                      [CurrentK in K]: T[CurrentK] extends { __type: "Union"; __primitiveFields: any }
                        ? Field[CurrentK] extends any[]
                          ? InferUnionFieldValue<T[CurrentK], Field[CurrentK]> | null
                          : never
                        : never
                    }
                  : NonNullable<T[K]> extends TypedSchema
                    ? null extends T[K]
                      ? InferResult<NonNullable<T[K]>, Field[K]> | null
                      : InferResult<NonNullable<T[K]>, Field[K]>
                    : never
          : never;
      }
    : never;

type InferResult<
  T extends TypedSchema,
  SelectedFields extends UnifiedFieldSelection<T>[] | undefined,
> = SelectedFields extends undefined
  ? {}
  : SelectedFields extends []
  ? {}
  : SelectedFields extends UnifiedFieldSelection<T>[]
  ? UnionToIntersection<
      {
        [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
      }[number]
    >
  : {};

// Pagination conditional types
// Checks if a page configuration object has any pagination parameters
type HasPaginationParams<Page> =
  Page extends { offset: any } ? true :
  Page extends { after: any } ? true :
  Page extends { before: any } ? true :
  false;

// Infer which pagination type is being used from the page config
type InferPaginationType<Page> =
  Page extends { offset: any } ? "offset" :
  Page extends { after: any } | { before: any } ? "keyset" :
  never;

// Returns either non-paginated (array) or paginated result based on page params
// For single pagination type support (offset-only or keyset-only)
// @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
type ConditionalPaginatedResult<
  Page,
  RecordType,
  PaginatedType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? PaginatedType
    : RecordType;

// For actions supporting both offset and keyset pagination
// Infers the specific pagination type based on which params were passed
type ConditionalPaginatedResultMixed<
  Page,
  RecordType,
  OffsetType,
  KeysetType
> = Page extends undefined
  ? RecordType
  : HasPaginationParams<Page> extends true
    ? InferPaginationType<Page> extends "offset"
      ? OffsetType
      : InferPaginationType<Page> extends "keyset"
        ? KeysetType
        : OffsetType | KeysetType  // Fallback to union if can't determine
    : RecordType;

export type SuccessDataFunc<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: true }
>["data"];


export type ErrorData<T extends (...args: any[]) => Promise<any>> = Extract<
  Awaited<ReturnType<T>>,
  { success: false }
>["errors"];

/**
 * Represents an error from an unsuccessful RPC call.
 *
 * This type matches the error structure defined in the AshTypescript.Rpc.Error protocol.
 *
 * @example
 * const error: AshRpcError = {
 *   type: "invalid_changes",
 *   message: "Invalid value for field %{field}",
 *   shortMessage: "Invalid changes",
 *   vars: { field: "email" },
 *   fields: ["email"],
 *   path: ["user", "email"],
 *   details: { suggestion: "Provide a valid email address" }
 * }
 */
export type AshRpcError = {
  /** Machine-readable error type (e.g., "invalid_changes", "not_found") */
  type: string;
  /** Full error message (may contain template variables like %{key}) */
  message: string;
  /** Concise version of the message */
  shortMessage: string;
  /** Variables to interpolate into the message template */
  vars: Record<string, any>;
  /** List of affected field names (for field-level errors) */
  fields: string[];
  /** Path to the error location in the data structure */
  path: string[];
  /** Optional map with extra details (e.g., suggestions, hints) */
  details?: Record<string, any>;
}

/**
 * Represents the result of a validation RPC call.
 *
 * All validation actions return this same structure, indicating either
 * successful validation or a list of validation errors.
 *
 * @example
 * // Successful validation
 * const result: ValidationResult = { success: true };
 *
 * // Failed validation
 * const result: ValidationResult = {
 *   success: false,
 *   errors: [
 *     {
 *       type: "required",
 *       message: "is required",
 *       shortMessage: "Required field",
 *       vars: { field: "email" },
 *       fields: ["email"],
 *       path: []
 *     }
 *   ]
 * };
 */
export type ValidationResult =
  | { success: true }
  | { success: false; errors: AshRpcError[]; };





// Helper Functions

/**
 * Configuration options for action RPC requests
 */
export interface ActionConfig {
  // Request data
  input?: Record<string, any>;
  primaryKey?: any;
  fields?: Array<string | Record<string, any>>; // Field selection
  filter?: Record<string, any>; // Filter options (for reads)
  sort?: string; // Sort options
  page?:
    | {
        // Offset-based pagination
        limit?: number;
        offset?: number;
        count?: boolean;
      }
    | {
        // Keyset pagination
        limit?: number;
        after?: string;
        before?: string;
      };

  // Metadata
  metadataFields?: ReadonlyArray<string>;

  // HTTP customization
  headers?: Record<string, string>; // Custom headers
  fetchOptions?: RequestInit; // Fetch options (signal, cache, etc.)
  customFetch?: (
    input: RequestInfo | URL,
    init?: RequestInit,
  ) => Promise<Response>;

  // Multitenancy
  tenant?: string; // Tenant parameter

  // Hook context
  hookCtx?: Record<string, any>;
}




/**
 * Gets the CSRF token from the page's meta tag
 * Returns null if no CSRF token is found
 */
export function getPhoenixCSRFToken(): string | null {
  return document
    ?.querySelector("meta[name='csrf-token']")
    ?.getAttribute("content") || null;
}

/**
 * Builds headers object with CSRF token for Phoenix applications
 * Returns headers object with X-CSRF-Token (if available)
 */
export function buildCSRFHeaders(headers: Record<string, string> = {}): Record<string, string> {
  const csrfToken = getPhoenixCSRFToken();
  if (csrfToken) {
    headers["X-CSRF-Token"] = csrfToken;
  }

  return headers;
}

/**
 * Internal helper function for making action RPC requests
 * Handles hooks, request configuration, fetch execution, and error handling
 * @param config Configuration matching ActionConfig
 */
async function executeActionRpcRequest<T>(
  payload: Record<string, any>,
  config: ActionConfig
): Promise<T> {
    const processedConfig = config;

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    ...config.headers,
    ...processedConfig.headers,
  };

  const fetchFunction = config.customFetch || processedConfig.customFetch || fetch;
  const fetchOptions: RequestInit = {
    ...config.fetchOptions,
    ...processedConfig.fetchOptions,
    method: "POST",
    headers,
    body: JSON.stringify(payload),
  };

  const response = await fetchFunction("/api/rpc/run", fetchOptions);
  const result = response.ok ? await response.json() : null;


  if (!response.ok) {
    return {
      success: false,
      errors: [
        {
          type: "network_error",
          message: `Network request failed: ${response.statusText}`,
          shortMessage: "Network error",
          vars: { statusCode: response.status, statusText: response.statusText },
          fields: [],
          path: [],
          details: { statusCode: response.status }
        }
      ],
    } as T;
  }

  return result as T;
}











export type ReadFields = UnifiedFieldSelection<UserResourceSchema>[];


export type InferReadResult<
  Fields extends ReadFields | undefined,
  Page extends ReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<UserResourceSchema, Fields>>, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<UserResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ReadConfig = {
  fields: ReadFields;
  filter?: UserFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ReadResult<Fields extends ReadFields, Page extends ReadConfig["page"] = undefined> = | { success: true; data: InferReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function read<Fields extends ReadFields, Config extends ReadConfig = ReadConfig>(
  config: Config & { fields: Fields }
): Promise<ReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type RegisterInput = {
  email: string;
  firstName: string;
  lastName: string;
  companyId?: UUID | null;
  password: string;
};

export const register = z.object({
  email: z.string().min(1),
  firstName: z.string().min(1),
  lastName: z.string().min(1),
  companyId: z.uuid().optional(),
  password: z.string().min(8),
});

export type RegisterFields = UnifiedFieldSelection<UserResourceSchema>[];

export type RegisterMetadata = {
  token: string;
};

export type InferRegisterResult<
  Fields extends RegisterFields | undefined,
  MetadataFields extends ReadonlyArray<keyof RegisterMetadata> = []
> = InferResult<UserResourceSchema, Fields>;

export type RegisterResult<Fields extends RegisterFields | undefined = undefined, MetadataFields extends ReadonlyArray<keyof RegisterMetadata> = []> = | { success: true; data: InferRegisterResult<Fields>; metadata: Pick<RegisterMetadata, MetadataFields[number]>; }
| { success: false; errors: AshRpcError[]; }

;

export async function register<Fields extends RegisterFields | undefined = undefined, MetadataFields extends ReadonlyArray<keyof RegisterMetadata> = []>(
  config: {
  input: RegisterInput;
  fields?: Fields;
  metadataFields?: MetadataFields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<RegisterResult<Fields extends undefined ? [] : Fields, MetadataFields>> {
  const payload = {
    action: "register",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.metadataFields && { metadataFields: config.metadataFields })
  };

  return executeActionRpcRequest<RegisterResult<Fields extends undefined ? [] : Fields, MetadataFields>>(
    payload,
    config
  );
}


export type SignInInput = {
  email: string;
  password: string;
};

export const signIn = z.object({
  email: z.string().min(1),
  password: z.string().min(1),
});

export type SignInFields = UnifiedFieldSelection<UserResourceSchema>[];

export type SignInMetadata = {
  token: string;
};

export type InferSignInResult<
  Fields extends SignInFields,
  MetadataFields extends ReadonlyArray<keyof SignInMetadata> = []
> = (InferResult<UserResourceSchema, Fields> & Pick<SignInMetadata, MetadataFields[number]>) | null;

export type SignInResult<Fields extends SignInFields, MetadataFields extends ReadonlyArray<keyof SignInMetadata> = []> = | { success: true; data: InferSignInResult<Fields, MetadataFields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function signIn<Fields extends SignInFields, MetadataFields extends ReadonlyArray<keyof SignInMetadata> = []>(
  config: {
  input: SignInInput;
  fields: Fields;
  metadataFields?: MetadataFields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<SignInResult<Fields, MetadataFields>> {
  const payload = {
    action: "sign_in",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.metadataFields && { metadataFields: config.metadataFields })
  };

  return executeActionRpcRequest<SignInResult<Fields, MetadataFields>>(
    payload,
    config
  );
}


export type CompanyReadFields = UnifiedFieldSelection<CompanyResourceSchema>[];


export type InferCompanyReadResult<
  Fields extends CompanyReadFields | undefined,
  Page extends CompanyReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CompanyResourceSchema, Fields>>, {
  results: Array<InferResult<CompanyResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CompanyResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type CompanyReadConfig = {
  fields: CompanyReadFields;
  filter?: CompanyFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type CompanyReadResult<Fields extends CompanyReadFields, Page extends CompanyReadConfig["page"] = undefined> = | { success: true; data: InferCompanyReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function companyRead<Fields extends CompanyReadFields, Config extends CompanyReadConfig = CompanyReadConfig>(
  config: Config & { fields: Fields }
): Promise<CompanyReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "company_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<CompanyReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type CompanyCreateInput = {
  name: string;
  orgNumber?: string | null;
  address?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  phone?: string | null;
  website?: string | null;
  employeeCount?: string | null;
  industry?: string | null;
  logoUrl?: string | null;
  billingAddress?: string | null;
  billingCity?: string | null;
  billingPostalCode?: string | null;
  billingCountry?: string | null;
};

export const companyCreate = z.object({
  name: z.string().min(1),
  orgNumber: z.string().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  postalCode: z.string().optional(),
  country: z.string().optional(),
  phone: z.string().optional(),
  website: z.string().optional(),
  employeeCount: z.string().optional(),
  industry: z.string().optional(),
  logoUrl: z.string().optional(),
  billingAddress: z.string().optional(),
  billingCity: z.string().optional(),
  billingPostalCode: z.string().optional(),
  billingCountry: z.string().optional(),
});

export type CompanyCreateFields = UnifiedFieldSelection<CompanyResourceSchema>[];

export type InferCompanyCreateResult<
  Fields extends CompanyCreateFields | undefined,
> = InferResult<CompanyResourceSchema, Fields>;

export type CompanyCreateResult<Fields extends CompanyCreateFields | undefined = undefined> = | { success: true; data: InferCompanyCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function companyCreate<Fields extends CompanyCreateFields | undefined = undefined>(
  config: {
  input: CompanyCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CompanyCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "company_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CompanyCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type CompanyUpdateInput = {
  name?: string;
  orgNumber?: string | null;
  address?: string | null;
  city?: string | null;
  postalCode?: string | null;
  country?: string | null;
  phone?: string | null;
  website?: string | null;
  employeeCount?: string | null;
  industry?: string | null;
  logoUrl?: string | null;
  billingAddress?: string | null;
  billingCity?: string | null;
  billingPostalCode?: string | null;
  billingCountry?: string | null;
};

export const companyUpdate = z.object({
  name: z.string().min(1).optional(),
  orgNumber: z.string().optional(),
  address: z.string().optional(),
  city: z.string().optional(),
  postalCode: z.string().optional(),
  country: z.string().optional(),
  phone: z.string().optional(),
  website: z.string().optional(),
  employeeCount: z.string().optional(),
  industry: z.string().optional(),
  logoUrl: z.string().optional(),
  billingAddress: z.string().optional(),
  billingCity: z.string().optional(),
  billingPostalCode: z.string().optional(),
  billingCountry: z.string().optional(),
});

export type CompanyUpdateFields = UnifiedFieldSelection<CompanyResourceSchema>[];

export type InferCompanyUpdateResult<
  Fields extends CompanyUpdateFields | undefined,
> = InferResult<CompanyResourceSchema, Fields>;

export type CompanyUpdateResult<Fields extends CompanyUpdateFields | undefined = undefined> = | { success: true; data: InferCompanyUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function companyUpdate<Fields extends CompanyUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: CompanyUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CompanyUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "company_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CompanyUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectReadFields = UnifiedFieldSelection<ProjectResourceSchema>[];


export type InferProjectReadResult<
  Fields extends ProjectReadFields | undefined,
  Page extends ProjectReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<ProjectResourceSchema, Fields>>, {
  results: Array<InferResult<ProjectResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<ProjectResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ProjectReadConfig = {
  fields: ProjectReadFields;
  filter?: ProjectFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ProjectReadResult<Fields extends ProjectReadFields, Page extends ProjectReadConfig["page"] = undefined> = | { success: true; data: InferProjectReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectRead<Fields extends ProjectReadFields, Config extends ProjectReadConfig = ProjectReadConfig>(
  config: Config & { fields: Fields }
): Promise<ProjectReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "project_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ProjectReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type ProjectCreateInput = {
  name: string;
  description?: string | null;
  companyId: UUID;
  budget?: Decimal | null;
  startDate?: AshDate | null;
  targetEndDate?: AshDate | null;
};

export const projectCreate = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
  companyId: z.uuid(),
  budget: z.string().optional(),
  startDate: z.iso.date().optional(),
  targetEndDate: z.iso.date().optional(),
});

export type ProjectCreateFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectCreateResult<
  Fields extends ProjectCreateFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectCreateResult<Fields extends ProjectCreateFields | undefined = undefined> = | { success: true; data: InferProjectCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectCreate<Fields extends ProjectCreateFields | undefined = undefined>(
  config: {
  input: ProjectCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectUpdateInput = {
  name?: string;
  description?: string | null;
  budget?: Decimal | null;
  targetEndDate?: AshDate | null;
};

export const projectUpdate = z.object({
  name: z.string().min(1).optional(),
  description: z.string().optional(),
  budget: z.string().optional(),
  targetEndDate: z.iso.date().optional(),
});

export type ProjectUpdateFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectUpdateResult<
  Fields extends ProjectUpdateFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectUpdateResult<Fields extends ProjectUpdateFields | undefined = undefined> = | { success: true; data: InferProjectUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectUpdate<Fields extends ProjectUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: ProjectUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectSubmitFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectSubmitResult<
  Fields extends ProjectSubmitFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectSubmitResult<Fields extends ProjectSubmitFields | undefined = undefined> = | { success: true; data: InferProjectSubmitResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectSubmit<Fields extends ProjectSubmitFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectSubmitResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_submit",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectSubmitResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectApproveFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectApproveResult<
  Fields extends ProjectApproveFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectApproveResult<Fields extends ProjectApproveFields | undefined = undefined> = | { success: true; data: InferProjectApproveResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectApprove<Fields extends ProjectApproveFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectApproveResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_approve",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectApproveResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectRejectInput = {
  rejectionReason?: string | null;
};

export const projectReject = z.object({
  rejectionReason: z.string().optional(),
});

export type ProjectRejectFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectRejectResult<
  Fields extends ProjectRejectFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectRejectResult<Fields extends ProjectRejectFields | undefined = undefined> = | { success: true; data: InferProjectRejectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectReject<Fields extends ProjectRejectFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input?: ProjectRejectInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectRejectResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_reject",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectRejectResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectPauseFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectPauseResult<
  Fields extends ProjectPauseFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectPauseResult<Fields extends ProjectPauseFields | undefined = undefined> = | { success: true; data: InferProjectPauseResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectPause<Fields extends ProjectPauseFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectPauseResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_pause",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectPauseResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectResumeFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectResumeResult<
  Fields extends ProjectResumeFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectResumeResult<Fields extends ProjectResumeFields | undefined = undefined> = | { success: true; data: InferProjectResumeResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectResume<Fields extends ProjectResumeFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectResumeResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_resume",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectResumeResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectCompleteFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectCompleteResult<
  Fields extends ProjectCompleteFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectCompleteResult<Fields extends ProjectCompleteFields | undefined = undefined> = | { success: true; data: InferProjectCompleteResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectComplete<Fields extends ProjectCompleteFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectCompleteResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_complete",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectCompleteResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectCancelInput = {
  cancellationReason?: string | null;
};

export const projectCancel = z.object({
  cancellationReason: z.string().optional(),
});

export type ProjectCancelFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectCancelResult<
  Fields extends ProjectCancelFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectCancelResult<Fields extends ProjectCancelFields | undefined = undefined> = | { success: true; data: InferProjectCancelResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectCancel<Fields extends ProjectCancelFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input?: ProjectCancelInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectCancelResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_cancel",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectCancelResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectSetPriorityInput = {
  isPriority?: boolean;
};

export const projectSetPriority = z.object({
  isPriority: z.boolean().optional(),
});

export type ProjectSetPriorityFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectSetPriorityResult<
  Fields extends ProjectSetPriorityFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectSetPriorityResult<Fields extends ProjectSetPriorityFields | undefined = undefined> = | { success: true; data: InferProjectSetPriorityResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectSetPriority<Fields extends ProjectSetPriorityFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input?: ProjectSetPriorityInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectSetPriorityResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_set_priority",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectSetPriorityResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProjectTogglePriorityFields = UnifiedFieldSelection<ProjectResourceSchema>[];

export type InferProjectTogglePriorityResult<
  Fields extends ProjectTogglePriorityFields | undefined,
> = InferResult<ProjectResourceSchema, Fields>;

export type ProjectTogglePriorityResult<Fields extends ProjectTogglePriorityFields | undefined = undefined> = | { success: true; data: InferProjectTogglePriorityResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function projectTogglePriority<Fields extends ProjectTogglePriorityFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProjectTogglePriorityResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "project_toggle_priority",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProjectTogglePriorityResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketReadFields = UnifiedFieldSelection<TicketResourceSchema>[];


export type InferTicketReadResult<
  Fields extends TicketReadFields | undefined,
  Page extends TicketReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<TicketResourceSchema, Fields>>, {
  results: Array<InferResult<TicketResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<TicketResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type TicketReadConfig = {
  fields: TicketReadFields;
  filter?: TicketFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type TicketReadResult<Fields extends TicketReadFields, Page extends TicketReadConfig["page"] = undefined> = | { success: true; data: InferTicketReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketRead<Fields extends TicketReadFields, Config extends TicketReadConfig = TicketReadConfig>(
  config: Config & { fields: Fields }
): Promise<TicketReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "ticket_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<TicketReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type TicketCreateInput = {
  title: string;
  description?: string | null;
  projectId: UUID;
  priority?: "low" | "medium" | "high" | "critical" | null;
  category?: "bug" | "feature" | "support" | "question" | "task" | null;
};

export const ticketCreate = z.object({
  title: z.string().min(1),
  description: z.string().optional(),
  projectId: z.uuid(),
  priority: z.enum(["low", "medium", "high", "critical"]).optional(),
  category: z.enum(["bug", "feature", "support", "question", "task"]).optional(),
});

export type TicketCreateFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketCreateResult<
  Fields extends TicketCreateFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketCreateResult<Fields extends TicketCreateFields | undefined = undefined> = | { success: true; data: InferTicketCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketCreate<Fields extends TicketCreateFields | undefined = undefined>(
  config: {
  input: TicketCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketUpdateInput = {
  title?: string;
  description?: string | null;
  priority?: "low" | "medium" | "high" | "critical" | null;
  category?: "bug" | "feature" | "support" | "question" | "task" | null;
};

export const ticketUpdate = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional(),
  priority: z.enum(["low", "medium", "high", "critical"]).optional(),
  category: z.enum(["bug", "feature", "support", "question", "task"]).optional(),
});

export type TicketUpdateFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketUpdateResult<
  Fields extends TicketUpdateFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketUpdateResult<Fields extends TicketUpdateFields | undefined = undefined> = | { success: true; data: InferTicketUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketUpdate<Fields extends TicketUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: TicketUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketAssignInput = {
  assigneeId: UUID;
};

export const ticketAssign = z.object({
  assigneeId: z.uuid(),
});

export type TicketAssignFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketAssignResult<
  Fields extends TicketAssignFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketAssignResult<Fields extends TicketAssignFields | undefined = undefined> = | { success: true; data: InferTicketAssignResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketAssign<Fields extends TicketAssignFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: TicketAssignInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketAssignResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_assign",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketAssignResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketStartWorkFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketStartWorkResult<
  Fields extends TicketStartWorkFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketStartWorkResult<Fields extends TicketStartWorkFields | undefined = undefined> = | { success: true; data: InferTicketStartWorkResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketStartWork<Fields extends TicketStartWorkFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketStartWorkResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_start_work",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketStartWorkResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketSubmitForReviewFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketSubmitForReviewResult<
  Fields extends TicketSubmitForReviewFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketSubmitForReviewResult<Fields extends TicketSubmitForReviewFields | undefined = undefined> = | { success: true; data: InferTicketSubmitForReviewResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketSubmitForReview<Fields extends TicketSubmitForReviewFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketSubmitForReviewResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_submit_for_review",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketSubmitForReviewResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketRequestChangesInput = {
  reviewNotes?: string | null;
};

export const ticketRequestChanges = z.object({
  reviewNotes: z.string().optional(),
});

export type TicketRequestChangesFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketRequestChangesResult<
  Fields extends TicketRequestChangesFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketRequestChangesResult<Fields extends TicketRequestChangesFields | undefined = undefined> = | { success: true; data: InferTicketRequestChangesResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketRequestChanges<Fields extends TicketRequestChangesFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input?: TicketRequestChangesInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketRequestChangesResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_request_changes",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketRequestChangesResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketApproveFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketApproveResult<
  Fields extends TicketApproveFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketApproveResult<Fields extends TicketApproveFields | undefined = undefined> = | { success: true; data: InferTicketApproveResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketApprove<Fields extends TicketApproveFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketApproveResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_approve",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketApproveResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketReopenFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketReopenResult<
  Fields extends TicketReopenFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketReopenResult<Fields extends TicketReopenFields | undefined = undefined> = | { success: true; data: InferTicketReopenResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketReopen<Fields extends TicketReopenFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketReopenResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_reopen",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketReopenResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TicketCloseFields = UnifiedFieldSelection<TicketResourceSchema>[];

export type InferTicketCloseResult<
  Fields extends TicketCloseFields | undefined,
> = InferResult<TicketResourceSchema, Fields>;

export type TicketCloseResult<Fields extends TicketCloseFields | undefined = undefined> = | { success: true; data: InferTicketCloseResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function ticketClose<Fields extends TicketCloseFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TicketCloseResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "ticket_close",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TicketCloseResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type CommentReadFields = UnifiedFieldSelection<CommentResourceSchema>[];


export type InferCommentReadResult<
  Fields extends CommentReadFields | undefined,
  Page extends CommentReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<CommentResourceSchema, Fields>>, {
  results: Array<InferResult<CommentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<CommentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type CommentReadConfig = {
  fields: CommentReadFields;
  filter?: CommentFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type CommentReadResult<Fields extends CommentReadFields, Page extends CommentReadConfig["page"] = undefined> = | { success: true; data: InferCommentReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function commentRead<Fields extends CommentReadFields, Config extends CommentReadConfig = CommentReadConfig>(
  config: Config & { fields: Fields }
): Promise<CommentReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "comment_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<CommentReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type CommentCreateInput = {
  body: string;
  ticketId: UUID;
  isInternal?: boolean | null;
};

export const commentCreate = z.object({
  body: z.string().min(1),
  ticketId: z.uuid(),
  isInternal: z.boolean().optional(),
});

export type CommentCreateFields = UnifiedFieldSelection<CommentResourceSchema>[];

export type InferCommentCreateResult<
  Fields extends CommentCreateFields | undefined,
> = InferResult<CommentResourceSchema, Fields>;

export type CommentCreateResult<Fields extends CommentCreateFields | undefined = undefined> = | { success: true; data: InferCommentCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function commentCreate<Fields extends CommentCreateFields | undefined = undefined>(
  config: {
  input: CommentCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<CommentCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "comment_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<CommentCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type TimeEntryReadFields = UnifiedFieldSelection<TimeEntryResourceSchema>[];


export type InferTimeEntryReadResult<
  Fields extends TimeEntryReadFields | undefined,
  Page extends TimeEntryReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<TimeEntryResourceSchema, Fields>>, {
  results: Array<InferResult<TimeEntryResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<TimeEntryResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type TimeEntryReadConfig = {
  fields: TimeEntryReadFields;
  filter?: TimeEntryFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type TimeEntryReadResult<Fields extends TimeEntryReadFields, Page extends TimeEntryReadConfig["page"] = undefined> = | { success: true; data: InferTimeEntryReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function timeEntryRead<Fields extends TimeEntryReadFields, Config extends TimeEntryReadConfig = TimeEntryReadConfig>(
  config: Config & { fields: Fields }
): Promise<TimeEntryReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "time_entry_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<TimeEntryReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type TimeEntryCreateInput = {
  description?: string | null;
  hours: Decimal;
  date: AshDate;
  projectId: UUID;
  ticketId?: UUID | null;
  hourlyRate?: Decimal | null;
  isBillable?: boolean | null;
};

export const timeEntryCreate = z.object({
  description: z.string().optional(),
  hours: z.string(),
  date: z.iso.date(),
  projectId: z.uuid(),
  ticketId: z.uuid().optional(),
  hourlyRate: z.string().optional(),
  isBillable: z.boolean().optional(),
});

export type TimeEntryCreateFields = UnifiedFieldSelection<TimeEntryResourceSchema>[];

export type InferTimeEntryCreateResult<
  Fields extends TimeEntryCreateFields | undefined,
> = InferResult<TimeEntryResourceSchema, Fields>;

export type TimeEntryCreateResult<Fields extends TimeEntryCreateFields | undefined = undefined> = | { success: true; data: InferTimeEntryCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function timeEntryCreate<Fields extends TimeEntryCreateFields | undefined = undefined>(
  config: {
  input: TimeEntryCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<TimeEntryCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "time_entry_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<TimeEntryCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type DocumentReadFields = UnifiedFieldSelection<DocumentResourceSchema>[];


export type InferDocumentReadResult<
  Fields extends DocumentReadFields | undefined,
  Page extends DocumentReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<DocumentResourceSchema, Fields>>, {
  results: Array<InferResult<DocumentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<DocumentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type DocumentReadConfig = {
  fields: DocumentReadFields;
  filter?: DocumentFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type DocumentReadResult<Fields extends DocumentReadFields, Page extends DocumentReadConfig["page"] = undefined> = | { success: true; data: InferDocumentReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function documentRead<Fields extends DocumentReadFields, Config extends DocumentReadConfig = DocumentReadConfig>(
  config: Config & { fields: Fields }
): Promise<DocumentReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "document_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<DocumentReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type DocumentCreateInput = {
  name: string;
  description?: string | null;
  filePath: string;
  fileSize?: number | null;
  mimeType?: string | null;
  projectId: UUID;
  category?: "contract" | "specification" | "design" | "report" | "invoice" | "other" | null;
};

export const documentCreate = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
  filePath: z.string().min(1),
  fileSize: z.number().int().optional(),
  mimeType: z.string().optional(),
  projectId: z.uuid(),
  category: z.enum(["contract", "specification", "design", "report", "invoice", "other"]).optional(),
});

export type DocumentCreateFields = UnifiedFieldSelection<DocumentResourceSchema>[];

export type InferDocumentCreateResult<
  Fields extends DocumentCreateFields | undefined,
> = InferResult<DocumentResourceSchema, Fields>;

export type DocumentCreateResult<Fields extends DocumentCreateFields | undefined = undefined> = | { success: true; data: InferDocumentCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function documentCreate<Fields extends DocumentCreateFields | undefined = undefined>(
  config: {
  input: DocumentCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<DocumentCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "document_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<DocumentCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type InvitationReadFields = UnifiedFieldSelection<InvitationResourceSchema>[];


export type InferInvitationReadResult<
  Fields extends InvitationReadFields | undefined,
  Page extends InvitationReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<InvitationResourceSchema, Fields>>, {
  results: Array<InferResult<InvitationResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<InvitationResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type InvitationReadConfig = {
  fields: InvitationReadFields;
  filter?: InvitationFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type InvitationReadResult<Fields extends InvitationReadFields, Page extends InvitationReadConfig["page"] = undefined> = | { success: true; data: InferInvitationReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function invitationRead<Fields extends InvitationReadFields, Config extends InvitationReadConfig = InvitationReadConfig>(
  config: Config & { fields: Fields }
): Promise<InvitationReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "invitation_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<InvitationReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type InvitationByTokenInput = {
  token: string;
};

export const invitationByToken = z.object({
  token: z.string().min(1),
});

export type InvitationByTokenFields = UnifiedFieldSelection<InvitationResourceSchema>[];
export type InferInvitationByTokenResult<
  Fields extends InvitationByTokenFields,
> = InferResult<InvitationResourceSchema, Fields> | null;

export type InvitationByTokenResult<Fields extends InvitationByTokenFields> = | { success: true; data: InferInvitationByTokenResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function invitationByToken<Fields extends InvitationByTokenFields>(
  config: {
  input: InvitationByTokenInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InvitationByTokenResult<Fields>> {
  const payload = {
    action: "invitation_by_token",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InvitationByTokenResult<Fields>>(
    payload,
    config
  );
}


export type InvitationPendingFields = UnifiedFieldSelection<InvitationResourceSchema>[];
export type InferInvitationPendingResult<
  Fields extends InvitationPendingFields,
> = Array<InferResult<InvitationResourceSchema, Fields>>;

export type InvitationPendingResult<Fields extends InvitationPendingFields> = | { success: true; data: InferInvitationPendingResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function invitationPending<Fields extends InvitationPendingFields>(
  config: {
  fields: Fields;
  filter?: InvitationFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InvitationPendingResult<Fields>> {
  const payload = {
    action: "invitation_pending",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<InvitationPendingResult<Fields>>(
    payload,
    config
  );
}


export type InvitationCreateInput = {
  email: string;
  companyId: UUID;
  role?: "customer" | null;
};

export const invitationCreate = z.object({
  email: z.string().min(1),
  companyId: z.uuid(),
  role: z.enum(["customer"]).optional(),
});

export type InvitationCreateFields = UnifiedFieldSelection<InvitationResourceSchema>[];

export type InferInvitationCreateResult<
  Fields extends InvitationCreateFields | undefined,
> = InferResult<InvitationResourceSchema, Fields>;

export type InvitationCreateResult<Fields extends InvitationCreateFields | undefined = undefined> = | { success: true; data: InferInvitationCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function invitationCreate<Fields extends InvitationCreateFields | undefined = undefined>(
  config: {
  input: InvitationCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InvitationCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "invitation_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InvitationCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type InvitationAcceptInput = {
  userId: UUID;
};

export const invitationAccept = z.object({
  userId: z.uuid(),
});

export type InvitationAcceptFields = UnifiedFieldSelection<InvitationResourceSchema>[];

export type InferInvitationAcceptResult<
  Fields extends InvitationAcceptFields | undefined,
> = InferResult<InvitationResourceSchema, Fields>;

export type InvitationAcceptResult<Fields extends InvitationAcceptFields | undefined = undefined> = | { success: true; data: InferInvitationAcceptResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function invitationAccept<Fields extends InvitationAcceptFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: InvitationAcceptInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InvitationAcceptResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "invitation_accept",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InvitationAcceptResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type InvitationCancelFields = UnifiedFieldSelection<InvitationResourceSchema>[];

export type InferInvitationCancelResult<
  Fields extends InvitationCancelFields | undefined,
> = InferResult<InvitationResourceSchema, Fields>;

export type InvitationCancelResult<Fields extends InvitationCancelFields | undefined = undefined> = | { success: true; data: InferInvitationCancelResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function invitationCancel<Fields extends InvitationCancelFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InvitationCancelResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "invitation_cancel",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InvitationCancelResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type FormResponseReadFields = UnifiedFieldSelection<FormResponseResourceSchema>[];


export type InferFormResponseReadResult<
  Fields extends FormResponseReadFields | undefined,
  Page extends FormResponseReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<FormResponseResourceSchema, Fields>>, {
  results: Array<InferResult<FormResponseResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<FormResponseResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type FormResponseReadConfig = {
  fields: FormResponseReadFields;
  filter?: FormResponseFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type FormResponseReadResult<Fields extends FormResponseReadFields, Page extends FormResponseReadConfig["page"] = undefined> = | { success: true; data: InferFormResponseReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseRead<Fields extends FormResponseReadFields, Config extends FormResponseReadConfig = FormResponseReadConfig>(
  config: Config & { fields: Fields }
): Promise<FormResponseReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "form_response_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<FormResponseReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type FormResponseByProjectInput = {
  projectId: UUID;
};

export const formResponseByProject = z.object({
  projectId: z.uuid(),
});

export type FormResponseByProjectFields = UnifiedFieldSelection<FormResponseResourceSchema>[];
export type InferFormResponseByProjectResult<
  Fields extends FormResponseByProjectFields,
> = Array<InferResult<FormResponseResourceSchema, Fields>>;

export type FormResponseByProjectResult<Fields extends FormResponseByProjectFields> = | { success: true; data: InferFormResponseByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseByProject<Fields extends FormResponseByProjectFields>(
  config: {
  input: FormResponseByProjectInput;
  fields: Fields;
  filter?: FormResponseFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FormResponseByProjectResult<Fields>> {
  const payload = {
    action: "form_response_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<FormResponseByProjectResult<Fields>>(
    payload,
    config
  );
}


export type FormResponseByProjectAndTypeInput = {
  projectId: UUID;
  formType: string;
};

export const formResponseByProjectAndType = z.object({
  projectId: z.uuid(),
  formType: z.string(),
});

export type FormResponseByProjectAndTypeFields = UnifiedFieldSelection<FormResponseResourceSchema>[];
export type InferFormResponseByProjectAndTypeResult<
  Fields extends FormResponseByProjectAndTypeFields,
> = Array<InferResult<FormResponseResourceSchema, Fields>>;

export type FormResponseByProjectAndTypeResult<Fields extends FormResponseByProjectAndTypeFields> = | { success: true; data: InferFormResponseByProjectAndTypeResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseByProjectAndType<Fields extends FormResponseByProjectAndTypeFields>(
  config: {
  input: FormResponseByProjectAndTypeInput;
  fields: Fields;
  filter?: FormResponseFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FormResponseByProjectAndTypeResult<Fields>> {
  const payload = {
    action: "form_response_by_project_and_type",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<FormResponseByProjectAndTypeResult<Fields>>(
    payload,
    config
  );
}


export type FormResponseBySectionInput = {
  projectId: UUID;
  section: string;
};

export const formResponseBySection = z.object({
  projectId: z.uuid(),
  section: z.string().min(1),
});

export type FormResponseBySectionFields = UnifiedFieldSelection<FormResponseResourceSchema>[];
export type InferFormResponseBySectionResult<
  Fields extends FormResponseBySectionFields,
> = Array<InferResult<FormResponseResourceSchema, Fields>>;

export type FormResponseBySectionResult<Fields extends FormResponseBySectionFields> = | { success: true; data: InferFormResponseBySectionResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseBySection<Fields extends FormResponseBySectionFields>(
  config: {
  input: FormResponseBySectionInput;
  fields: Fields;
  filter?: FormResponseFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FormResponseBySectionResult<Fields>> {
  const payload = {
    action: "form_response_by_section",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<FormResponseBySectionResult<Fields>>(
    payload,
    config
  );
}


export type FormResponseCreateInput = {
  projectId: UUID;
  formType: "website" | "system" | "both";
  section: string;
  questionKey: string;
  answerValue: Record<string, any>;
  answerMetadata?: Record<string, any> | null;
};

export const formResponseCreate = z.object({
  projectId: z.uuid(),
  formType: z.enum(["website", "system", "both"]),
  section: z.string().min(1),
  questionKey: z.string().min(1),
  answerValue: z.record(z.string(), z.any()),
  answerMetadata: z.record(z.string(), z.any()).optional(),
});

export type FormResponseCreateFields = UnifiedFieldSelection<FormResponseResourceSchema>[];

export type InferFormResponseCreateResult<
  Fields extends FormResponseCreateFields | undefined,
> = InferResult<FormResponseResourceSchema, Fields>;

export type FormResponseCreateResult<Fields extends FormResponseCreateFields | undefined = undefined> = | { success: true; data: InferFormResponseCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseCreate<Fields extends FormResponseCreateFields | undefined = undefined>(
  config: {
  input: FormResponseCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FormResponseCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "form_response_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<FormResponseCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type FormResponseUpdateInput = {
  answerValue?: Record<string, any>;
  answerMetadata?: Record<string, any> | null;
};

export const formResponseUpdate = z.object({
  answerValue: z.record(z.string(), z.any()).optional(),
  answerMetadata: z.record(z.string(), z.any()).optional(),
});

export type FormResponseUpdateFields = UnifiedFieldSelection<FormResponseResourceSchema>[];

export type InferFormResponseUpdateResult<
  Fields extends FormResponseUpdateFields | undefined,
> = InferResult<FormResponseResourceSchema, Fields>;

export type FormResponseUpdateResult<Fields extends FormResponseUpdateFields | undefined = undefined> = | { success: true; data: InferFormResponseUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseUpdate<Fields extends FormResponseUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: FormResponseUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FormResponseUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "form_response_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<FormResponseUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}



export type FormResponseDestroyResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function formResponseDestroy(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<FormResponseDestroyResult> {
  const payload = {
    action: "form_response_destroy",
    primaryKey: config.primaryKey
  };

  return executeActionRpcRequest<FormResponseDestroyResult>(
    payload,
    config
  );
}


export type InternalNoteReadFields = UnifiedFieldSelection<InternalNoteResourceSchema>[];


export type InferInternalNoteReadResult<
  Fields extends InternalNoteReadFields | undefined,
  Page extends InternalNoteReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<InternalNoteResourceSchema, Fields>>, {
  results: Array<InferResult<InternalNoteResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<InternalNoteResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type InternalNoteReadConfig = {
  fields: InternalNoteReadFields;
  filter?: InternalNoteFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type InternalNoteReadResult<Fields extends InternalNoteReadFields, Page extends InternalNoteReadConfig["page"] = undefined> = | { success: true; data: InferInternalNoteReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function internalNoteRead<Fields extends InternalNoteReadFields, Config extends InternalNoteReadConfig = InternalNoteReadConfig>(
  config: Config & { fields: Fields }
): Promise<InternalNoteReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "internal_note_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<InternalNoteReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type InternalNoteByProjectInput = {
  projectId: UUID;
};

export const internalNoteByProject = z.object({
  projectId: z.uuid(),
});

export type InternalNoteByProjectFields = UnifiedFieldSelection<InternalNoteResourceSchema>[];
export type InferInternalNoteByProjectResult<
  Fields extends InternalNoteByProjectFields,
> = Array<InferResult<InternalNoteResourceSchema, Fields>>;

export type InternalNoteByProjectResult<Fields extends InternalNoteByProjectFields> = | { success: true; data: InferInternalNoteByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function internalNoteByProject<Fields extends InternalNoteByProjectFields>(
  config: {
  input: InternalNoteByProjectInput;
  fields: Fields;
  filter?: InternalNoteFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InternalNoteByProjectResult<Fields>> {
  const payload = {
    action: "internal_note_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<InternalNoteByProjectResult<Fields>>(
    payload,
    config
  );
}


export type InternalNoteCreateInput = {
  content: string;
  projectId: UUID;
};

export const internalNoteCreate = z.object({
  content: z.string().min(1),
  projectId: z.uuid(),
});

export type InternalNoteCreateFields = UnifiedFieldSelection<InternalNoteResourceSchema>[];

export type InferInternalNoteCreateResult<
  Fields extends InternalNoteCreateFields | undefined,
> = InferResult<InternalNoteResourceSchema, Fields>;

export type InternalNoteCreateResult<Fields extends InternalNoteCreateFields | undefined = undefined> = | { success: true; data: InferInternalNoteCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function internalNoteCreate<Fields extends InternalNoteCreateFields | undefined = undefined>(
  config: {
  input: InternalNoteCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InternalNoteCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "internal_note_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InternalNoteCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type InternalNoteUpdateInput = {
  content?: string;
};

export const internalNoteUpdate = z.object({
  content: z.string().min(1).optional(),
});

export type InternalNoteUpdateFields = UnifiedFieldSelection<InternalNoteResourceSchema>[];

export type InferInternalNoteUpdateResult<
  Fields extends InternalNoteUpdateFields | undefined,
> = InferResult<InternalNoteResourceSchema, Fields>;

export type InternalNoteUpdateResult<Fields extends InternalNoteUpdateFields | undefined = undefined> = | { success: true; data: InferInternalNoteUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function internalNoteUpdate<Fields extends InternalNoteUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: InternalNoteUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InternalNoteUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "internal_note_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<InternalNoteUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}



export type InternalNoteDestroyResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function internalNoteDestroy(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<InternalNoteDestroyResult> {
  const payload = {
    action: "internal_note_destroy",
    primaryKey: config.primaryKey
  };

  return executeActionRpcRequest<InternalNoteDestroyResult>(
    payload,
    config
  );
}


export type GeneratedDocumentReadFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];


export type InferGeneratedDocumentReadResult<
  Fields extends GeneratedDocumentReadFields | undefined,
  Page extends GeneratedDocumentReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<GeneratedDocumentResourceSchema, Fields>>, {
  results: Array<InferResult<GeneratedDocumentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<GeneratedDocumentResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type GeneratedDocumentReadConfig = {
  fields: GeneratedDocumentReadFields;
  filter?: GeneratedDocumentFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type GeneratedDocumentReadResult<Fields extends GeneratedDocumentReadFields, Page extends GeneratedDocumentReadConfig["page"] = undefined> = | { success: true; data: InferGeneratedDocumentReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentRead<Fields extends GeneratedDocumentReadFields, Config extends GeneratedDocumentReadConfig = GeneratedDocumentReadConfig>(
  config: Config & { fields: Fields }
): Promise<GeneratedDocumentReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "generated_document_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<GeneratedDocumentReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type GeneratedDocumentByProjectInput = {
  projectId: UUID;
};

export const generatedDocumentByProject = z.object({
  projectId: z.uuid(),
});

export type GeneratedDocumentByProjectFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];
export type InferGeneratedDocumentByProjectResult<
  Fields extends GeneratedDocumentByProjectFields,
> = Array<InferResult<GeneratedDocumentResourceSchema, Fields>>;

export type GeneratedDocumentByProjectResult<Fields extends GeneratedDocumentByProjectFields> = | { success: true; data: InferGeneratedDocumentByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentByProject<Fields extends GeneratedDocumentByProjectFields>(
  config: {
  input: GeneratedDocumentByProjectInput;
  fields: Fields;
  filter?: GeneratedDocumentFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentByProjectResult<Fields>> {
  const payload = {
    action: "generated_document_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<GeneratedDocumentByProjectResult<Fields>>(
    payload,
    config
  );
}


export type GeneratedDocumentByProjectAndTypeInput = {
  projectId: UUID;
  documentType: string;
};

export const generatedDocumentByProjectAndType = z.object({
  projectId: z.uuid(),
  documentType: z.string().min(1),
});

export type GeneratedDocumentByProjectAndTypeFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];
export type InferGeneratedDocumentByProjectAndTypeResult<
  Fields extends GeneratedDocumentByProjectAndTypeFields,
> = InferResult<GeneratedDocumentResourceSchema, Fields> | null;

export type GeneratedDocumentByProjectAndTypeResult<Fields extends GeneratedDocumentByProjectAndTypeFields> = | { success: true; data: InferGeneratedDocumentByProjectAndTypeResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentByProjectAndType<Fields extends GeneratedDocumentByProjectAndTypeFields>(
  config: {
  input: GeneratedDocumentByProjectAndTypeInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentByProjectAndTypeResult<Fields>> {
  const payload = {
    action: "generated_document_by_project_and_type",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GeneratedDocumentByProjectAndTypeResult<Fields>>(
    payload,
    config
  );
}


export type GeneratedDocumentCreateInput = {
  projectId: UUID;
  documentType: "project_spec" | "technical_requirements" | "design_brief" | "budget_timeline";
  title: string;
  content: string;
  generatedById?: UUID | null;
  generationMetadata?: Record<string, any> | null;
};

export const generatedDocumentCreate = z.object({
  projectId: z.uuid(),
  documentType: z.enum(["project_spec", "technical_requirements", "design_brief", "budget_timeline"]),
  title: z.string().min(1),
  content: z.string().min(1),
  generatedById: z.uuid().optional(),
  generationMetadata: z.record(z.string(), z.any()).optional(),
});

export type GeneratedDocumentCreateFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];

export type InferGeneratedDocumentCreateResult<
  Fields extends GeneratedDocumentCreateFields | undefined,
> = InferResult<GeneratedDocumentResourceSchema, Fields>;

export type GeneratedDocumentCreateResult<Fields extends GeneratedDocumentCreateFields | undefined = undefined> = | { success: true; data: InferGeneratedDocumentCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentCreate<Fields extends GeneratedDocumentCreateFields | undefined = undefined>(
  config: {
  input: GeneratedDocumentCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "generated_document_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GeneratedDocumentCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type GeneratedDocumentUpdateInput = {
  title?: string;
  content?: string;
  status?: "draft" | "published" | "archived";
  generationMetadata?: Record<string, any> | null;
};

export const generatedDocumentUpdate = z.object({
  title: z.string().min(1).optional(),
  content: z.string().min(1).optional(),
  status: z.enum(["draft", "published", "archived"]).optional(),
  generationMetadata: z.record(z.string(), z.any()).optional(),
});

export type GeneratedDocumentUpdateFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];

export type InferGeneratedDocumentUpdateResult<
  Fields extends GeneratedDocumentUpdateFields | undefined,
> = InferResult<GeneratedDocumentResourceSchema, Fields>;

export type GeneratedDocumentUpdateResult<Fields extends GeneratedDocumentUpdateFields | undefined = undefined> = | { success: true; data: InferGeneratedDocumentUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentUpdate<Fields extends GeneratedDocumentUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: GeneratedDocumentUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "generated_document_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GeneratedDocumentUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type GeneratedDocumentPublishFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];

export type InferGeneratedDocumentPublishResult<
  Fields extends GeneratedDocumentPublishFields | undefined,
> = InferResult<GeneratedDocumentResourceSchema, Fields>;

export type GeneratedDocumentPublishResult<Fields extends GeneratedDocumentPublishFields | undefined = undefined> = | { success: true; data: InferGeneratedDocumentPublishResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentPublish<Fields extends GeneratedDocumentPublishFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentPublishResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "generated_document_publish",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GeneratedDocumentPublishResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type GeneratedDocumentArchiveFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];

export type InferGeneratedDocumentArchiveResult<
  Fields extends GeneratedDocumentArchiveFields | undefined,
> = InferResult<GeneratedDocumentResourceSchema, Fields>;

export type GeneratedDocumentArchiveResult<Fields extends GeneratedDocumentArchiveFields | undefined = undefined> = | { success: true; data: InferGeneratedDocumentArchiveResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentArchive<Fields extends GeneratedDocumentArchiveFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentArchiveResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "generated_document_archive",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GeneratedDocumentArchiveResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type GeneratedDocumentRegenerateInput = {
  content?: string;
  generationMetadata?: Record<string, any> | null;
};

export const generatedDocumentRegenerate = z.object({
  content: z.string().min(1).optional(),
  generationMetadata: z.record(z.string(), z.any()).optional(),
});

export type GeneratedDocumentRegenerateFields = UnifiedFieldSelection<GeneratedDocumentResourceSchema>[];

export type InferGeneratedDocumentRegenerateResult<
  Fields extends GeneratedDocumentRegenerateFields | undefined,
> = InferResult<GeneratedDocumentResourceSchema, Fields>;

export type GeneratedDocumentRegenerateResult<Fields extends GeneratedDocumentRegenerateFields | undefined = undefined> = | { success: true; data: InferGeneratedDocumentRegenerateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function generatedDocumentRegenerate<Fields extends GeneratedDocumentRegenerateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: GeneratedDocumentRegenerateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<GeneratedDocumentRegenerateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "generated_document_regenerate",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<GeneratedDocumentRegenerateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ChatMessageReadFields = UnifiedFieldSelection<ChatMessageResourceSchema>[];


export type InferChatMessageReadResult<
  Fields extends ChatMessageReadFields | undefined,
  Page extends ChatMessageReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<ChatMessageResourceSchema, Fields>>, {
  results: Array<InferResult<ChatMessageResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<ChatMessageResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ChatMessageReadConfig = {
  fields: ChatMessageReadFields;
  filter?: ChatMessageFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ChatMessageReadResult<Fields extends ChatMessageReadFields, Page extends ChatMessageReadConfig["page"] = undefined> = | { success: true; data: InferChatMessageReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function chatMessageRead<Fields extends ChatMessageReadFields, Config extends ChatMessageReadConfig = ChatMessageReadConfig>(
  config: Config & { fields: Fields }
): Promise<ChatMessageReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "chat_message_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ChatMessageReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type ChatMessageByProjectInput = {
  projectId: UUID;
};

export const chatMessageByProject = z.object({
  projectId: z.uuid(),
});

export type ChatMessageByProjectFields = UnifiedFieldSelection<ChatMessageResourceSchema>[];
export type InferChatMessageByProjectResult<
  Fields extends ChatMessageByProjectFields,
> = Array<InferResult<ChatMessageResourceSchema, Fields>>;

export type ChatMessageByProjectResult<Fields extends ChatMessageByProjectFields> = | { success: true; data: InferChatMessageByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function chatMessageByProject<Fields extends ChatMessageByProjectFields>(
  config: {
  input: ChatMessageByProjectInput;
  fields: Fields;
  filter?: ChatMessageFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ChatMessageByProjectResult<Fields>> {
  const payload = {
    action: "chat_message_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ChatMessageByProjectResult<Fields>>(
    payload,
    config
  );
}


export type ChatMessageProjectHistoryInput = {
  projectId: UUID;
  limit?: number;
};

export const chatMessageProjectHistory = z.object({
  projectId: z.uuid(),
  limit: z.number().int().optional(),
});

export type ChatMessageProjectHistoryFields = UnifiedFieldSelection<ChatMessageResourceSchema>[];
export type InferChatMessageProjectHistoryResult<
  Fields extends ChatMessageProjectHistoryFields,
> = Array<InferResult<ChatMessageResourceSchema, Fields>>;

export type ChatMessageProjectHistoryResult<Fields extends ChatMessageProjectHistoryFields> = | { success: true; data: InferChatMessageProjectHistoryResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function chatMessageProjectHistory<Fields extends ChatMessageProjectHistoryFields>(
  config: {
  input: ChatMessageProjectHistoryInput;
  fields: Fields;
  filter?: ChatMessageFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ChatMessageProjectHistoryResult<Fields>> {
  const payload = {
    action: "chat_message_project_history",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ChatMessageProjectHistoryResult<Fields>>(
    payload,
    config
  );
}


export type ChatMessageCreateInput = {
  projectId: UUID;
  userId: UUID;
  role: "user" | "assistant";
  content: string;
  sources?: Array<Record<string, any>> | null;
  metadata?: Record<string, any> | null;
};

export const chatMessageCreate = z.object({
  projectId: z.uuid(),
  userId: z.uuid(),
  role: z.enum(["user", "assistant"]),
  content: z.string().min(1),
  sources: z.array(z.record(z.string(), z.any())).optional(),
  metadata: z.record(z.string(), z.any()).optional(),
});

export type ChatMessageCreateFields = UnifiedFieldSelection<ChatMessageResourceSchema>[];

export type InferChatMessageCreateResult<
  Fields extends ChatMessageCreateFields | undefined,
> = InferResult<ChatMessageResourceSchema, Fields>;

export type ChatMessageCreateResult<Fields extends ChatMessageCreateFields | undefined = undefined> = | { success: true; data: InferChatMessageCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function chatMessageCreate<Fields extends ChatMessageCreateFields | undefined = undefined>(
  config: {
  input: ChatMessageCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ChatMessageCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "chat_message_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ChatMessageCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ChatMessageClearProjectHistoryInput = {
  projectId: UUID;
};

export const chatMessageClearProjectHistory = z.object({
  projectId: z.uuid(),
});


export type ChatMessageClearProjectHistoryResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function chatMessageClearProjectHistory(
  config: {
  primaryKey: UUID;
  input: ChatMessageClearProjectHistoryInput;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ChatMessageClearProjectHistoryResult> {
  const payload = {
    action: "chat_message_clear_project_history",
    primaryKey: config.primaryKey,
    input: config.input
  };

  return executeActionRpcRequest<ChatMessageClearProjectHistoryResult>(
    payload,
    config
  );
}


export type ManualKnowledgeEntryReadFields = UnifiedFieldSelection<ManualKnowledgeEntryResourceSchema>[];


export type InferManualKnowledgeEntryReadResult<
  Fields extends ManualKnowledgeEntryReadFields | undefined,
  Page extends ManualKnowledgeEntryReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<ManualKnowledgeEntryResourceSchema, Fields>>, {
  results: Array<InferResult<ManualKnowledgeEntryResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<ManualKnowledgeEntryResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ManualKnowledgeEntryReadConfig = {
  fields: ManualKnowledgeEntryReadFields;
  filter?: ManualKnowledgeEntryFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ManualKnowledgeEntryReadResult<Fields extends ManualKnowledgeEntryReadFields, Page extends ManualKnowledgeEntryReadConfig["page"] = undefined> = | { success: true; data: InferManualKnowledgeEntryReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function manualKnowledgeEntryRead<Fields extends ManualKnowledgeEntryReadFields, Config extends ManualKnowledgeEntryReadConfig = ManualKnowledgeEntryReadConfig>(
  config: Config & { fields: Fields }
): Promise<ManualKnowledgeEntryReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "manual_knowledge_entry_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ManualKnowledgeEntryReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type ManualKnowledgeEntryByProjectInput = {
  projectId: UUID;
};

export const manualKnowledgeEntryByProject = z.object({
  projectId: z.uuid(),
});

export type ManualKnowledgeEntryByProjectFields = UnifiedFieldSelection<ManualKnowledgeEntryResourceSchema>[];
export type InferManualKnowledgeEntryByProjectResult<
  Fields extends ManualKnowledgeEntryByProjectFields,
> = Array<InferResult<ManualKnowledgeEntryResourceSchema, Fields>>;

export type ManualKnowledgeEntryByProjectResult<Fields extends ManualKnowledgeEntryByProjectFields> = | { success: true; data: InferManualKnowledgeEntryByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function manualKnowledgeEntryByProject<Fields extends ManualKnowledgeEntryByProjectFields>(
  config: {
  input: ManualKnowledgeEntryByProjectInput;
  fields: Fields;
  filter?: ManualKnowledgeEntryFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ManualKnowledgeEntryByProjectResult<Fields>> {
  const payload = {
    action: "manual_knowledge_entry_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ManualKnowledgeEntryByProjectResult<Fields>>(
    payload,
    config
  );
}


export type ManualKnowledgeEntryByCategoryInput = {
  projectId: UUID;
  category: string;
};

export const manualKnowledgeEntryByCategory = z.object({
  projectId: z.uuid(),
  category: z.string().min(1),
});

export type ManualKnowledgeEntryByCategoryFields = UnifiedFieldSelection<ManualKnowledgeEntryResourceSchema>[];
export type InferManualKnowledgeEntryByCategoryResult<
  Fields extends ManualKnowledgeEntryByCategoryFields,
> = Array<InferResult<ManualKnowledgeEntryResourceSchema, Fields>>;

export type ManualKnowledgeEntryByCategoryResult<Fields extends ManualKnowledgeEntryByCategoryFields> = | { success: true; data: InferManualKnowledgeEntryByCategoryResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function manualKnowledgeEntryByCategory<Fields extends ManualKnowledgeEntryByCategoryFields>(
  config: {
  input: ManualKnowledgeEntryByCategoryInput;
  fields: Fields;
  filter?: ManualKnowledgeEntryFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ManualKnowledgeEntryByCategoryResult<Fields>> {
  const payload = {
    action: "manual_knowledge_entry_by_category",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ManualKnowledgeEntryByCategoryResult<Fields>>(
    payload,
    config
  );
}


export type ManualKnowledgeEntryCreateInput = {
  projectId: UUID;
  title: string;
  content: string;
  rawInput?: string | null;
  category?: "meeting_notes" | "decision" | "clarification" | "feedback" | "technical" | "design" | "other";
  metadata?: Record<string, any> | null;
};

export const manualKnowledgeEntryCreate = z.object({
  projectId: z.uuid(),
  title: z.string().min(1),
  content: z.string().min(1),
  rawInput: z.string().optional(),
  category: z.enum(["meeting_notes", "decision", "clarification", "feedback", "technical", "design", "other"]).optional(),
  metadata: z.record(z.string(), z.any()).optional(),
});

export type ManualKnowledgeEntryCreateFields = UnifiedFieldSelection<ManualKnowledgeEntryResourceSchema>[];

export type InferManualKnowledgeEntryCreateResult<
  Fields extends ManualKnowledgeEntryCreateFields | undefined,
> = InferResult<ManualKnowledgeEntryResourceSchema, Fields>;

export type ManualKnowledgeEntryCreateResult<Fields extends ManualKnowledgeEntryCreateFields | undefined = undefined> = | { success: true; data: InferManualKnowledgeEntryCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function manualKnowledgeEntryCreate<Fields extends ManualKnowledgeEntryCreateFields | undefined = undefined>(
  config: {
  input: ManualKnowledgeEntryCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ManualKnowledgeEntryCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "manual_knowledge_entry_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ManualKnowledgeEntryCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ManualKnowledgeEntryUpdateInput = {
  title?: string;
  content?: string;
  category?: "meeting_notes" | "decision" | "clarification" | "feedback" | "technical" | "design" | "other";
  metadata?: Record<string, any> | null;
};

export const manualKnowledgeEntryUpdate = z.object({
  title: z.string().min(1).optional(),
  content: z.string().min(1).optional(),
  category: z.enum(["meeting_notes", "decision", "clarification", "feedback", "technical", "design", "other"]).optional(),
  metadata: z.record(z.string(), z.any()).optional(),
});

export type ManualKnowledgeEntryUpdateFields = UnifiedFieldSelection<ManualKnowledgeEntryResourceSchema>[];

export type InferManualKnowledgeEntryUpdateResult<
  Fields extends ManualKnowledgeEntryUpdateFields | undefined,
> = InferResult<ManualKnowledgeEntryResourceSchema, Fields>;

export type ManualKnowledgeEntryUpdateResult<Fields extends ManualKnowledgeEntryUpdateFields | undefined = undefined> = | { success: true; data: InferManualKnowledgeEntryUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function manualKnowledgeEntryUpdate<Fields extends ManualKnowledgeEntryUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: ManualKnowledgeEntryUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ManualKnowledgeEntryUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "manual_knowledge_entry_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ManualKnowledgeEntryUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}



export type ManualKnowledgeEntryDestroyResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function manualKnowledgeEntryDestroy(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ManualKnowledgeEntryDestroyResult> {
  const payload = {
    action: "manual_knowledge_entry_destroy",
    primaryKey: config.primaryKey
  };

  return executeActionRpcRequest<ManualKnowledgeEntryDestroyResult>(
    payload,
    config
  );
}


export type ProductPlanReadFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];


export type InferProductPlanReadResult<
  Fields extends ProductPlanReadFields | undefined,
  Page extends ProductPlanReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<ProductPlanResourceSchema, Fields>>, {
  results: Array<InferResult<ProductPlanResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<ProductPlanResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type ProductPlanReadConfig = {
  fields: ProductPlanReadFields;
  filter?: ProductPlanFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type ProductPlanReadResult<Fields extends ProductPlanReadFields, Page extends ProductPlanReadConfig["page"] = undefined> = | { success: true; data: InferProductPlanReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanRead<Fields extends ProductPlanReadFields, Config extends ProductPlanReadConfig = ProductPlanReadConfig>(
  config: Config & { fields: Fields }
): Promise<ProductPlanReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "product_plan_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<ProductPlanReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type ProductPlanByProjectInput = {
  projectId: UUID;
};

export const productPlanByProject = z.object({
  projectId: z.uuid(),
});

export type ProductPlanByProjectFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];
export type InferProductPlanByProjectResult<
  Fields extends ProductPlanByProjectFields,
> = Array<InferResult<ProductPlanResourceSchema, Fields>>;

export type ProductPlanByProjectResult<Fields extends ProductPlanByProjectFields> = | { success: true; data: InferProductPlanByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanByProject<Fields extends ProductPlanByProjectFields>(
  config: {
  input: ProductPlanByProjectInput;
  fields: Fields;
  filter?: ProductPlanFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanByProjectResult<Fields>> {
  const payload = {
    action: "product_plan_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ProductPlanByProjectResult<Fields>>(
    payload,
    config
  );
}


export type ProductPlanActiveByProjectInput = {
  projectId: UUID;
};

export const productPlanActiveByProject = z.object({
  projectId: z.uuid(),
});

export type ProductPlanActiveByProjectFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];
export type InferProductPlanActiveByProjectResult<
  Fields extends ProductPlanActiveByProjectFields,
> = InferResult<ProductPlanResourceSchema, Fields> | null;

export type ProductPlanActiveByProjectResult<Fields extends ProductPlanActiveByProjectFields> = | { success: true; data: InferProductPlanActiveByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanActiveByProject<Fields extends ProductPlanActiveByProjectFields>(
  config: {
  input: ProductPlanActiveByProjectInput;
  fields: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanActiveByProjectResult<Fields>> {
  const payload = {
    action: "product_plan_active_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanActiveByProjectResult<Fields>>(
    payload,
    config
  );
}


export type ProductPlanPendingApprovalFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];
export type InferProductPlanPendingApprovalResult<
  Fields extends ProductPlanPendingApprovalFields,
> = Array<InferResult<ProductPlanResourceSchema, Fields>>;

export type ProductPlanPendingApprovalResult<Fields extends ProductPlanPendingApprovalFields> = | { success: true; data: InferProductPlanPendingApprovalResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanPendingApproval<Fields extends ProductPlanPendingApprovalFields>(
  config: {
  fields: Fields;
  filter?: ProductPlanFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanPendingApprovalResult<Fields>> {
  const payload = {
    action: "product_plan_pending_approval",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ProductPlanPendingApprovalResult<Fields>>(
    payload,
    config
  );
}


export type ProductPlanNeedingRevisionFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];
export type InferProductPlanNeedingRevisionResult<
  Fields extends ProductPlanNeedingRevisionFields,
> = Array<InferResult<ProductPlanResourceSchema, Fields>>;

export type ProductPlanNeedingRevisionResult<Fields extends ProductPlanNeedingRevisionFields> = | { success: true; data: InferProductPlanNeedingRevisionResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanNeedingRevision<Fields extends ProductPlanNeedingRevisionFields>(
  config: {
  fields: Fields;
  filter?: ProductPlanFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanNeedingRevisionResult<Fields>> {
  const payload = {
    action: "product_plan_needing_revision",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<ProductPlanNeedingRevisionResult<Fields>>(
    payload,
    config
  );
}


export type ProductPlanCreateInput = {
  projectId: UUID;
  title: string;
  content: string;
  summary?: string | null;
  pdfUrl?: string | null;
  metadata?: Record<string, any> | null;
};

export const productPlanCreate = z.object({
  projectId: z.uuid(),
  title: z.string().min(1),
  content: z.string().min(1),
  summary: z.string().optional(),
  pdfUrl: z.string().optional(),
  metadata: z.record(z.string(), z.any()).optional(),
});

export type ProductPlanCreateFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanCreateResult<
  Fields extends ProductPlanCreateFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanCreateResult<Fields extends ProductPlanCreateFields | undefined = undefined> = | { success: true; data: InferProductPlanCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanCreate<Fields extends ProductPlanCreateFields | undefined = undefined>(
  config: {
  input: ProductPlanCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanUpdateInput = {
  title?: string;
  content?: string;
  summary?: string | null;
  pdfUrl?: string | null;
  metadata?: Record<string, any> | null;
};

export const productPlanUpdate = z.object({
  title: z.string().min(1).optional(),
  content: z.string().min(1).optional(),
  summary: z.string().optional(),
  pdfUrl: z.string().optional(),
  metadata: z.record(z.string(), z.any()).optional(),
});

export type ProductPlanUpdateFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanUpdateResult<
  Fields extends ProductPlanUpdateFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanUpdateResult<Fields extends ProductPlanUpdateFields | undefined = undefined> = | { success: true; data: InferProductPlanUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanUpdate<Fields extends ProductPlanUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: ProductPlanUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanSendToCustomerFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanSendToCustomerResult<
  Fields extends ProductPlanSendToCustomerFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanSendToCustomerResult<Fields extends ProductPlanSendToCustomerFields | undefined = undefined> = | { success: true; data: InferProductPlanSendToCustomerResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanSendToCustomer<Fields extends ProductPlanSendToCustomerFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanSendToCustomerResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_send_to_customer",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanSendToCustomerResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanMarkViewedFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanMarkViewedResult<
  Fields extends ProductPlanMarkViewedFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanMarkViewedResult<Fields extends ProductPlanMarkViewedFields | undefined = undefined> = | { success: true; data: InferProductPlanMarkViewedResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanMarkViewed<Fields extends ProductPlanMarkViewedFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanMarkViewedResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_mark_viewed",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanMarkViewedResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanApproveInput = {
  feedback?: string;
};

export const productPlanApprove = z.object({
  feedback: z.string().optional(),
});

export type ProductPlanApproveFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanApproveResult<
  Fields extends ProductPlanApproveFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanApproveResult<Fields extends ProductPlanApproveFields | undefined = undefined> = | { success: true; data: InferProductPlanApproveResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanApprove<Fields extends ProductPlanApproveFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input?: ProductPlanApproveInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanApproveResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_approve",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanApproveResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanRequestChangesInput = {
  feedback: string;
  changeRequests?: Record<string, any>;
};

export const productPlanRequestChanges = z.object({
  feedback: z.string().min(1),
  changeRequests: z.record(z.string(), z.any()).optional(),
});

export type ProductPlanRequestChangesFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanRequestChangesResult<
  Fields extends ProductPlanRequestChangesFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanRequestChangesResult<Fields extends ProductPlanRequestChangesFields | undefined = undefined> = | { success: true; data: InferProductPlanRequestChangesResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanRequestChanges<Fields extends ProductPlanRequestChangesFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: ProductPlanRequestChangesInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanRequestChangesResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_request_changes",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanRequestChangesResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanReviseInput = {
  title?: string;
  content?: string;
  summary?: string | null;
  pdfUrl?: string | null;
};

export const productPlanRevise = z.object({
  title: z.string().min(1).optional(),
  content: z.string().min(1).optional(),
  summary: z.string().optional(),
  pdfUrl: z.string().optional(),
});

export type ProductPlanReviseFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanReviseResult<
  Fields extends ProductPlanReviseFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanReviseResult<Fields extends ProductPlanReviseFields | undefined = undefined> = | { success: true; data: InferProductPlanReviseResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanRevise<Fields extends ProductPlanReviseFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: ProductPlanReviseInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanReviseResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_revise",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanReviseResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type ProductPlanArchiveFields = UnifiedFieldSelection<ProductPlanResourceSchema>[];

export type InferProductPlanArchiveResult<
  Fields extends ProductPlanArchiveFields | undefined,
> = InferResult<ProductPlanResourceSchema, Fields>;

export type ProductPlanArchiveResult<Fields extends ProductPlanArchiveFields | undefined = undefined> = | { success: true; data: InferProductPlanArchiveResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanArchive<Fields extends ProductPlanArchiveFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanArchiveResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "product_plan_archive",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<ProductPlanArchiveResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}



export type ProductPlanDestroyResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function productPlanDestroy(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<ProductPlanDestroyResult> {
  const payload = {
    action: "product_plan_destroy",
    primaryKey: config.primaryKey
  };

  return executeActionRpcRequest<ProductPlanDestroyResult>(
    payload,
    config
  );
}


export type MilestoneReadFields = UnifiedFieldSelection<MilestoneResourceSchema>[];


export type InferMilestoneReadResult<
  Fields extends MilestoneReadFields | undefined,
  Page extends MilestoneReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<MilestoneResourceSchema, Fields>>, {
  results: Array<InferResult<MilestoneResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<MilestoneResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type MilestoneReadConfig = {
  fields: MilestoneReadFields;
  filter?: MilestoneFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type MilestoneReadResult<Fields extends MilestoneReadFields, Page extends MilestoneReadConfig["page"] = undefined> = | { success: true; data: InferMilestoneReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneRead<Fields extends MilestoneReadFields, Config extends MilestoneReadConfig = MilestoneReadConfig>(
  config: Config & { fields: Fields }
): Promise<MilestoneReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "milestone_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<MilestoneReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type MilestoneByProjectInput = {
  projectId: UUID;
};

export const milestoneByProject = z.object({
  projectId: z.uuid(),
});

export type MilestoneByProjectFields = UnifiedFieldSelection<MilestoneResourceSchema>[];
export type InferMilestoneByProjectResult<
  Fields extends MilestoneByProjectFields,
> = Array<InferResult<MilestoneResourceSchema, Fields>>;

export type MilestoneByProjectResult<Fields extends MilestoneByProjectFields> = | { success: true; data: InferMilestoneByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneByProject<Fields extends MilestoneByProjectFields>(
  config: {
  input: MilestoneByProjectInput;
  fields: Fields;
  filter?: MilestoneFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MilestoneByProjectResult<Fields>> {
  const payload = {
    action: "milestone_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<MilestoneByProjectResult<Fields>>(
    payload,
    config
  );
}


export type MilestoneCreateInput = {
  title: string;
  description?: string | null;
  dueDate?: AshDate | null;
  orderIndex?: number | null;
  status?: "pending" | "in_progress" | "completed" | null;
  projectId: UUID;
};

export const milestoneCreate = z.object({
  title: z.string().min(1),
  description: z.string().optional(),
  dueDate: z.iso.date().optional(),
  orderIndex: z.number().int().optional(),
  status: z.enum(["pending", "in_progress", "completed"]).optional(),
  projectId: z.uuid(),
});

export type MilestoneCreateFields = UnifiedFieldSelection<MilestoneResourceSchema>[];

export type InferMilestoneCreateResult<
  Fields extends MilestoneCreateFields | undefined,
> = InferResult<MilestoneResourceSchema, Fields>;

export type MilestoneCreateResult<Fields extends MilestoneCreateFields | undefined = undefined> = | { success: true; data: InferMilestoneCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneCreate<Fields extends MilestoneCreateFields | undefined = undefined>(
  config: {
  input: MilestoneCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MilestoneCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "milestone_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MilestoneCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MilestoneUpdateInput = {
  title?: string;
  description?: string | null;
  dueDate?: AshDate | null;
  orderIndex?: number | null;
  status?: "pending" | "in_progress" | "completed" | null;
};

export const milestoneUpdate = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional(),
  dueDate: z.iso.date().optional(),
  orderIndex: z.number().int().optional(),
  status: z.enum(["pending", "in_progress", "completed"]).optional(),
});

export type MilestoneUpdateFields = UnifiedFieldSelection<MilestoneResourceSchema>[];

export type InferMilestoneUpdateResult<
  Fields extends MilestoneUpdateFields | undefined,
> = InferResult<MilestoneResourceSchema, Fields>;

export type MilestoneUpdateResult<Fields extends MilestoneUpdateFields | undefined = undefined> = | { success: true; data: InferMilestoneUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneUpdate<Fields extends MilestoneUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: MilestoneUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MilestoneUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "milestone_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MilestoneUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MilestoneMarkCompletedFields = UnifiedFieldSelection<MilestoneResourceSchema>[];

export type InferMilestoneMarkCompletedResult<
  Fields extends MilestoneMarkCompletedFields | undefined,
> = InferResult<MilestoneResourceSchema, Fields>;

export type MilestoneMarkCompletedResult<Fields extends MilestoneMarkCompletedFields | undefined = undefined> = | { success: true; data: InferMilestoneMarkCompletedResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneMarkCompleted<Fields extends MilestoneMarkCompletedFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MilestoneMarkCompletedResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "milestone_mark_completed",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MilestoneMarkCompletedResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MilestoneReopenFields = UnifiedFieldSelection<MilestoneResourceSchema>[];

export type InferMilestoneReopenResult<
  Fields extends MilestoneReopenFields | undefined,
> = InferResult<MilestoneResourceSchema, Fields>;

export type MilestoneReopenResult<Fields extends MilestoneReopenFields | undefined = undefined> = | { success: true; data: InferMilestoneReopenResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneReopen<Fields extends MilestoneReopenFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MilestoneReopenResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "milestone_reopen",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MilestoneReopenResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}



export type MilestoneDestroyResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function milestoneDestroy(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MilestoneDestroyResult> {
  const payload = {
    action: "milestone_destroy",
    primaryKey: config.primaryKey
  };

  return executeActionRpcRequest<MilestoneDestroyResult>(
    payload,
    config
  );
}


export type MeetingReadFields = UnifiedFieldSelection<MeetingResourceSchema>[];


export type InferMeetingReadResult<
  Fields extends MeetingReadFields | undefined,
  Page extends MeetingReadConfig["page"] = undefined
> = ConditionalPaginatedResultMixed<Page, Array<InferResult<MeetingResourceSchema, Fields>>, {
  results: Array<InferResult<MeetingResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  offset: number;
  count?: number | null;
  type: "offset";
}, {
  results: Array<InferResult<MeetingResourceSchema, Fields>>;
  hasMore: boolean;
  limit: number;
  after: string | null;
  before: string | null;
  previousPage: string;
  nextPage: string;
  count?: number | null;
  type: "keyset";
}>;

export type MeetingReadConfig = {
  fields: MeetingReadFields;
  filter?: MeetingFilterInput;
  sort?: string;
  page?: (
    {
      limit?: number;
      offset?: number;
      count?: boolean;
    } | {
      limit?: number;
      after?: string;
      before?: string;
    }
  );
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
};

export type MeetingReadResult<Fields extends MeetingReadFields, Page extends MeetingReadConfig["page"] = undefined> = | { success: true; data: InferMeetingReadResult<Fields, Page>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingRead<Fields extends MeetingReadFields, Config extends MeetingReadConfig = MeetingReadConfig>(
  config: Config & { fields: Fields }
): Promise<MeetingReadResult<Fields, Config["page"]>> {
  const payload = {
    action: "meeting_read",
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort }),
    ...(config.page && { page: config.page })
  };

  return executeActionRpcRequest<MeetingReadResult<Fields, Config["page"]>>(
    payload,
    config
  );
}


export type MeetingByProjectInput = {
  projectId: UUID;
};

export const meetingByProject = z.object({
  projectId: z.uuid(),
});

export type MeetingByProjectFields = UnifiedFieldSelection<MeetingResourceSchema>[];
export type InferMeetingByProjectResult<
  Fields extends MeetingByProjectFields,
> = Array<InferResult<MeetingResourceSchema, Fields>>;

export type MeetingByProjectResult<Fields extends MeetingByProjectFields> = | { success: true; data: InferMeetingByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingByProject<Fields extends MeetingByProjectFields>(
  config: {
  input: MeetingByProjectInput;
  fields: Fields;
  filter?: MeetingFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingByProjectResult<Fields>> {
  const payload = {
    action: "meeting_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<MeetingByProjectResult<Fields>>(
    payload,
    config
  );
}


export type MeetingUpcomingByProjectInput = {
  projectId: UUID;
};

export const meetingUpcomingByProject = z.object({
  projectId: z.uuid(),
});

export type MeetingUpcomingByProjectFields = UnifiedFieldSelection<MeetingResourceSchema>[];
export type InferMeetingUpcomingByProjectResult<
  Fields extends MeetingUpcomingByProjectFields,
> = Array<InferResult<MeetingResourceSchema, Fields>>;

export type MeetingUpcomingByProjectResult<Fields extends MeetingUpcomingByProjectFields> = | { success: true; data: InferMeetingUpcomingByProjectResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingUpcomingByProject<Fields extends MeetingUpcomingByProjectFields>(
  config: {
  input: MeetingUpcomingByProjectInput;
  fields: Fields;
  filter?: MeetingFilterInput;
  sort?: string;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingUpcomingByProjectResult<Fields>> {
  const payload = {
    action: "meeting_upcoming_by_project",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields }),
    ...(config.filter && { filter: config.filter }),
    ...(config.sort && { sort: config.sort })
  };

  return executeActionRpcRequest<MeetingUpcomingByProjectResult<Fields>>(
    payload,
    config
  );
}


export type MeetingCreateInput = {
  title: string;
  description?: string | null;
  meetingType?: "kickoff" | "status_update" | "review" | "planning" | "retrospective" | "other" | null;
  scheduledAt?: UtcDateTimeUsec | null;
  durationMinutes?: number | null;
  location?: string | null;
  meetingUrl?: string | null;
  notes?: string | null;
  actionItems?: Record<string, any> | null;
  attendees?: Array<string> | null;
  status?: "scheduled" | "in_progress" | "completed" | "cancelled" | null;
  projectId: UUID;
};

export const meetingCreate = z.object({
  title: z.string().min(1),
  description: z.string().optional(),
  meetingType: z.enum(["kickoff", "status_update", "review", "planning", "retrospective", "other"]).optional(),
  scheduledAt: z.iso.datetime().optional(),
  durationMinutes: z.number().int().optional(),
  location: z.string().optional(),
  meetingUrl: z.string().optional(),
  notes: z.string().optional(),
  actionItems: z.record(z.string(), z.any()).optional(),
  attendees: z.array(z.string()).optional(),
  status: z.enum(["scheduled", "in_progress", "completed", "cancelled"]).optional(),
  projectId: z.uuid(),
});

export type MeetingCreateFields = UnifiedFieldSelection<MeetingResourceSchema>[];

export type InferMeetingCreateResult<
  Fields extends MeetingCreateFields | undefined,
> = InferResult<MeetingResourceSchema, Fields>;

export type MeetingCreateResult<Fields extends MeetingCreateFields | undefined = undefined> = | { success: true; data: InferMeetingCreateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingCreate<Fields extends MeetingCreateFields | undefined = undefined>(
  config: {
  input: MeetingCreateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingCreateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "meeting_create",
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MeetingCreateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MeetingUpdateInput = {
  title?: string;
  description?: string | null;
  meetingType?: "kickoff" | "status_update" | "review" | "planning" | "retrospective" | "other" | null;
  scheduledAt?: UtcDateTimeUsec | null;
  durationMinutes?: number | null;
  location?: string | null;
  meetingUrl?: string | null;
  notes?: string | null;
  actionItems?: Record<string, any> | null;
  attendees?: Array<string> | null;
  status?: "scheduled" | "in_progress" | "completed" | "cancelled" | null;
};

export const meetingUpdate = z.object({
  title: z.string().min(1).optional(),
  description: z.string().optional(),
  meetingType: z.enum(["kickoff", "status_update", "review", "planning", "retrospective", "other"]).optional(),
  scheduledAt: z.iso.datetime().optional(),
  durationMinutes: z.number().int().optional(),
  location: z.string().optional(),
  meetingUrl: z.string().optional(),
  notes: z.string().optional(),
  actionItems: z.record(z.string(), z.any()).optional(),
  attendees: z.array(z.string()).optional(),
  status: z.enum(["scheduled", "in_progress", "completed", "cancelled"]).optional(),
});

export type MeetingUpdateFields = UnifiedFieldSelection<MeetingResourceSchema>[];

export type InferMeetingUpdateResult<
  Fields extends MeetingUpdateFields | undefined,
> = InferResult<MeetingResourceSchema, Fields>;

export type MeetingUpdateResult<Fields extends MeetingUpdateFields | undefined = undefined> = | { success: true; data: InferMeetingUpdateResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingUpdate<Fields extends MeetingUpdateFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input: MeetingUpdateInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingUpdateResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "meeting_update",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MeetingUpdateResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MeetingStartFields = UnifiedFieldSelection<MeetingResourceSchema>[];

export type InferMeetingStartResult<
  Fields extends MeetingStartFields | undefined,
> = InferResult<MeetingResourceSchema, Fields>;

export type MeetingStartResult<Fields extends MeetingStartFields | undefined = undefined> = | { success: true; data: InferMeetingStartResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingStart<Fields extends MeetingStartFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingStartResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "meeting_start",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MeetingStartResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MeetingCompleteInput = {
  notes?: string | null;
  actionItems?: Record<string, any> | null;
};

export const meetingComplete = z.object({
  notes: z.string().optional(),
  actionItems: z.record(z.string(), z.any()).optional(),
});

export type MeetingCompleteFields = UnifiedFieldSelection<MeetingResourceSchema>[];

export type InferMeetingCompleteResult<
  Fields extends MeetingCompleteFields | undefined,
> = InferResult<MeetingResourceSchema, Fields>;

export type MeetingCompleteResult<Fields extends MeetingCompleteFields | undefined = undefined> = | { success: true; data: InferMeetingCompleteResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingComplete<Fields extends MeetingCompleteFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  input?: MeetingCompleteInput;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingCompleteResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "meeting_complete",
    primaryKey: config.primaryKey,
    input: config.input,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MeetingCompleteResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}


export type MeetingCancelFields = UnifiedFieldSelection<MeetingResourceSchema>[];

export type InferMeetingCancelResult<
  Fields extends MeetingCancelFields | undefined,
> = InferResult<MeetingResourceSchema, Fields>;

export type MeetingCancelResult<Fields extends MeetingCancelFields | undefined = undefined> = | { success: true; data: InferMeetingCancelResult<Fields>; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingCancel<Fields extends MeetingCancelFields | undefined = undefined>(
  config: {
  primaryKey: UUID;
  fields?: Fields;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingCancelResult<Fields extends undefined ? [] : Fields>> {
  const payload = {
    action: "meeting_cancel",
    primaryKey: config.primaryKey,
    ...(config.fields !== undefined && { fields: config.fields })
  };

  return executeActionRpcRequest<MeetingCancelResult<Fields extends undefined ? [] : Fields>>(
    payload,
    config
  );
}



export type MeetingDestroyResult = | { success: true; data: {}; }
| { success: false; errors: AshRpcError[]; }

;

export async function meetingDestroy(
  config: {
  primaryKey: UUID;
  headers?: Record<string, string>;
  fetchOptions?: RequestInit;
  customFetch?: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>;
}
): Promise<MeetingDestroyResult> {
  const payload = {
    action: "meeting_destroy",
    primaryKey: config.primaryKey
  };

  return executeActionRpcRequest<MeetingDestroyResult>(
    payload,
    config
  );
}


